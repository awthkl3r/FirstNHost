import { HasuraAuthClient as f } from "@nhost/hasura-auth-js";
export * from "@nhost/hasura-auth-js";
import { HasuraStorageClient as g } from "@nhost/hasura-storage-js";
export * from "@nhost/hasura-storage-js";
import p from "isomorphic-unfetch";
import { NhostGraphqlClient as w } from "@nhost/graphql-js";
const b = /^((?<protocol>http[s]?):\/\/)?(?<host>(localhost|local))(:(?<port>(\d+|__\w+__)))?$/;
function d(e, t) {
  const { backendUrl: i, subdomain: o, region: a } = e;
  if (i)
    return `${i}/v1/${t}`;
  if (!o)
    throw new Error("Either `backendUrl` or `subdomain` must be set.");
  const u = o.match(b);
  if (u != null && u.groups) {
    const { protocol: s, host: c, port: r } = u.groups, n = k(t);
    return n || (c === "localhost" ? (console.warn(
      'The `subdomain` is set to "localhost". Support for this will be removed in a future release. Please use "local" instead.'
    ), `${s || "http"}://localhost:${r || 1337}/v1/${t}`) : r ? `${s || "https"}://local.${t}.nhost.run:${r}/v1` : `${s || "https"}://local.${t}.nhost.run/v1`);
  }
  if (!a)
    throw new Error('`region` must be set when using a `subdomain` other than "local".');
  return `https://${o}.${t}.${a}.nhost.run/v1`;
}
function T() {
  return typeof window != "undefined";
}
function m() {
  return typeof process != "undefined" && process.env;
}
function k(e) {
  return T() || !m() ? null : process.env[`NHOST_${e.toUpperCase()}_URL`];
}
function U(e, t) {
  const o = t.startsWith("/") ? t : `/${t}`;
  return e + o;
}
function S(e) {
  const t = "subdomain" in e || "backendUrl" in e ? d(e, "auth") : e.authUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `authUrl`.");
  return new f({ url: t, ...e });
}
function A(e) {
  const t = "subdomain" in e || "backendUrl" in e ? d(e, "functions") : e.functionsUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `functionsUrl`.");
  return new $({ url: t, ...e });
}
class $ {
  constructor(t) {
    const { url: i, adminSecret: o } = t;
    this.url = i, this.accessToken = null, this.adminSecret = o;
  }
  async call(t, i, o) {
    var s, c;
    const a = {
      "Content-Type": "application/json",
      ...this.generateAccessTokenHeaders(),
      ...o == null ? void 0 : o.headers
    }, u = U(this.url, t);
    try {
      const r = await p(u, {
        body: i ? JSON.stringify(i) : null,
        headers: a,
        method: "POST"
      });
      if (!r.ok) {
        let l;
        return (s = r.headers.get("content-type")) != null && s.includes("application/json") ? l = await r.json() : l = await r.text(), {
          res: null,
          error: {
            message: l,
            error: r.statusText,
            status: r.status
          }
        };
      }
      let n;
      return (c = r.headers.get("content-type")) != null && c.includes("application/json") ? n = await r.json() : n = await r.text(), {
        res: { data: n, status: r.status, statusText: r.statusText },
        error: null
      };
    } catch (r) {
      const n = r;
      return {
        res: null,
        error: {
          message: n.message,
          status: n.name === "AbortError" ? 0 : 500,
          error: n.name === "AbortError" ? "abort-error" : "unknown"
        }
      };
    }
  }
  setAccessToken(t) {
    if (!t) {
      this.accessToken = null;
      return;
    }
    this.accessToken = t;
  }
  generateAccessTokenHeaders() {
    return this.adminSecret ? {
      "x-hasura-admin-secret": this.adminSecret
    } : this.accessToken ? {
      Authorization: `Bearer ${this.accessToken}`
    } : {};
  }
}
function v(e) {
  const t = "subdomain" in e || "backendUrl" in e ? d(e, "graphql") : e.graphqlUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `graphqlUrl`.");
  return new w({ url: t, ...e });
}
function C(e) {
  const t = "subdomain" in e || "backendUrl" in e ? d(e, "storage") : e.storageUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `storageUrl`.");
  return new g({ url: t, ...e });
}
const N = (e) => new E(e);
class E {
  constructor({
    refreshIntervalTime: t,
    clientStorage: i,
    clientStorageType: o,
    autoRefreshToken: a,
    autoSignIn: u,
    adminSecret: s,
    devTools: c,
    start: r = !0,
    ...n
  }) {
    this.auth = S({
      refreshIntervalTime: t,
      clientStorage: i,
      clientStorageType: o,
      autoRefreshToken: a,
      autoSignIn: u,
      start: r,
      ...n
    }), this.storage = C({ adminSecret: s, ...n }), this.functions = A({ adminSecret: s, ...n }), this.graphql = v({ adminSecret: s, ...n }), this.auth.onAuthStateChanged((l, h) => {
      l === "SIGNED_OUT" && (this.storage.setAccessToken(void 0), this.functions.setAccessToken(void 0), this.graphql.setAccessToken(void 0));
    }), this.auth.onTokenChanged((l) => {
      const h = l == null ? void 0 : l.accessToken;
      this.storage.setAccessToken(h), this.functions.setAccessToken(h), this.graphql.setAccessToken(h);
    }), this._adminSecret = s, this.devTools = c;
  }
  get adminSecret() {
    return this._adminSecret;
  }
  set adminSecret(t) {
    this._adminSecret = t, this.storage.setAdminSecret(t);
  }
}
export {
  E as NhostClient,
  $ as NhostFunctionsClient,
  S as createAuthClient,
  A as createFunctionsClient,
  v as createGraphqlClient,
  N as createNhostClient,
  C as createStorageClient
};
//# sourceMappingURL=index.esm.js.map
