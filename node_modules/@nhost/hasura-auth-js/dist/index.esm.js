import ae from "jwt-decode";
import { createMachine as _, send as p, assign as m, interpret as R } from "xstate";
import V from "js-cookie";
import ce from "isomorphic-unfetch";
const b = "nhostRefreshToken", P = "nhostRefreshTokenExpiresAt", ue = 3, le = 300, j = 5, X = 0, Z = 1, T = 10, O = 20;
class D extends Error {
  constructor(e) {
    super(e.message), Error.captureStackTrace(this, this.constructor), e instanceof Error ? (this.name = e.name, this.error = {
      error: e.name,
      status: Z,
      message: e.message
    }) : (this.name = e.error, this.error = e);
  }
}
const S = {
  status: T,
  error: "invalid-email",
  message: "Email is incorrectly formatted"
}, de = {
  status: T,
  error: "invalid-mfa-type",
  message: "MFA type is invalid"
}, fe = {
  status: T,
  error: "invalid-mfa-code",
  message: "MFA code is invalid"
}, G = {
  status: T,
  error: "invalid-password",
  message: "Password is incorrectly formatted"
}, H = {
  status: T,
  error: "invalid-phone-number",
  message: "Phone number is incorrectly formatted"
}, he = {
  status: T,
  error: "invalid-mfa-ticket",
  message: "MFA ticket is invalid"
}, me = {
  status: T,
  error: "no-mfa-ticket",
  message: "No MFA ticket has been provided"
}, Ee = {
  status: T,
  error: "no-refresh-token",
  message: "No refresh token has been provided"
}, ge = {
  status: O,
  error: "refresher-already-running",
  message: "The token refresher is already running. You must wait until is has finished before submitting a new token."
}, y = {
  status: O,
  error: "already-signed-in",
  message: "User is already signed in"
}, pe = {
  status: O,
  error: "unauthenticated-user",
  message: "User is not authenticated"
}, tr = {
  status: O,
  error: "user-not-anonymous",
  message: "User is not anonymous"
}, we = {
  status: O,
  error: "unverified-user",
  message: "Email needs verification"
}, Te = {
  status: T,
  error: "invalid-refresh-token",
  message: "Invalid or expired refresh token"
}, ye = {
  status: Z,
  error: "invalid-sign-in-method",
  message: "Invalid sign-in method"
}, K = {
  user: null,
  mfa: null,
  accessToken: {
    value: null,
    expiresAt: null
  },
  refreshTimer: {
    startedAt: null,
    attempts: 0,
    lastAttempt: null
  },
  refreshToken: {
    value: null
  },
  importTokenAttempts: 0,
  errors: {}
};
function Se(n) {
  return new TextEncoder().encode(n);
}
function I(n) {
  const e = new Uint8Array(n);
  let t = "";
  for (const s of e)
    t += String.fromCharCode(s);
  return btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function q(n) {
  const e = n.replace(/-/g, "+").replace(/_/g, "/"), t = (4 - e.length % 4) % 4, r = e.padEnd(e.length + t, "="), s = atob(r), i = new ArrayBuffer(s.length), c = new Uint8Array(i);
  for (let l = 0; l < s.length; l++)
    c[l] = s.charCodeAt(l);
  return i;
}
function J() {
  return (window == null ? void 0 : window.PublicKeyCredential) !== void 0 && typeof window.PublicKeyCredential == "function";
}
function ee(n) {
  const { id: e } = n;
  return {
    ...n,
    id: q(e),
    transports: n.transports
  };
}
function re(n) {
  return n === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n);
}
class g extends Error {
  constructor(e, t = "WebAuthnError") {
    super(e), this.name = t;
  }
}
function ve({ error: n, options: e }) {
  var t, r;
  const { publicKey: s } = e;
  if (!s)
    throw Error("options was missing required publicKey property");
  if (n.name === "AbortError") {
    if (e.signal === new AbortController().signal)
      return new g("Registration ceremony was sent an abort signal", "AbortError");
  } else if (n.name === "ConstraintError") {
    if (((t = s.authenticatorSelection) === null || t === void 0 ? void 0 : t.requireResidentKey) === !0)
      return new g("Discoverable credentials were required but no available authenticator supported it", "ConstraintError");
    if (((r = s.authenticatorSelection) === null || r === void 0 ? void 0 : r.userVerification) === "required")
      return new g("User verification was required but no available authenticator supported it", "ConstraintError");
  } else {
    if (n.name === "InvalidStateError")
      return new g("The authenticator was previously registered", "InvalidStateError");
    if (n.name === "NotAllowedError")
      return new g("User clicked cancel, or the registration ceremony timed out", "NotAllowedError");
    if (n.name === "NotSupportedError")
      return s.pubKeyCredParams.filter((c) => c.type === "public-key").length === 0 ? new g('No entry in pubKeyCredParams was of type "public-key"', "NotSupportedError") : new g("No available authenticator supported any of the specified pubKeyCredParams algorithms", "NotSupportedError");
    if (n.name === "SecurityError") {
      const i = window.location.hostname;
      if (re(i)) {
        if (s.rp.id !== i)
          return new g(`The RP ID "${s.rp.id}" is invalid for this domain`, "SecurityError");
      } else
        return new g(`${window.location.hostname} is an invalid domain`, "SecurityError");
    } else if (n.name === "TypeError") {
      if (s.user.id.byteLength < 1 || s.user.id.byteLength > 64)
        return new g("User ID was not between 1 and 64 characters", "TypeError");
    } else if (n.name === "UnknownError")
      return new g("The authenticator was unable to process the specified options, or could not create a new credential", "UnknownError");
  }
  return n;
}
class ke {
  createNewAbortSignal() {
    return this.controller && this.controller.abort(), this.controller = new AbortController(), this.controller.signal;
  }
  reset() {
    this.controller = void 0;
  }
}
const U = new ke();
async function te(n) {
  if (!J())
    throw new Error("WebAuthn is not supported in this browser");
  const t = { publicKey: {
    ...n,
    challenge: q(n.challenge),
    user: {
      ...n.user,
      id: Se(n.user.id)
    },
    excludeCredentials: n.excludeCredentials.map(ee)
  } };
  t.signal = U.createNewAbortSignal();
  let r;
  try {
    r = await navigator.credentials.create(t);
  } catch (f) {
    throw ve({ error: f, options: t });
  } finally {
    U.reset();
  }
  if (!r)
    throw new Error("Registration was not completed");
  const { id: s, rawId: i, response: c, type: l } = r, h = {
    id: s,
    rawId: I(i),
    response: {
      attestationObject: I(c.attestationObject),
      clientDataJSON: I(c.clientDataJSON)
    },
    type: l,
    clientExtensionResults: r.getClientExtensionResults(),
    authenticatorAttachment: r.authenticatorAttachment
  };
  return typeof c.getTransports == "function" && (h.transports = c.getTransports()), h;
}
function Ae(n) {
  return new TextDecoder("utf-8").decode(n);
}
async function Ie() {
  if (navigator.credentials.conditionalMediationSupported)
    return !0;
  const n = window.PublicKeyCredential;
  return n.isConditionalMediationAvailable !== void 0 && n.isConditionalMediationAvailable();
}
function _e({ error: n, options: e }) {
  var t;
  const { publicKey: r } = e;
  if (!r)
    throw Error("options was missing required publicKey property");
  if (n.name === "AbortError") {
    if (e.signal === new AbortController().signal)
      return new g("Authentication ceremony was sent an abort signal", "AbortError");
  } else {
    if (n.name === "NotAllowedError")
      return !((t = r.allowCredentials) === null || t === void 0) && t.length ? new g("No available authenticator recognized any of the allowed credentials", "NotAllowedError") : new g("User clicked cancel, or the authentication ceremony timed out", "NotAllowedError");
    if (n.name === "SecurityError") {
      const s = window.location.hostname;
      if (re(s)) {
        if (r.rpId !== s)
          return new g(`The RP ID "${r.rpId}" is invalid for this domain`, "SecurityError");
      } else
        return new g(`${window.location.hostname} is an invalid domain`, "SecurityError");
    } else if (n.name === "UnknownError")
      return new g("The authenticator was unable to process the specified options, or could not create a new assertion signature", "UnknownError");
  }
  return n;
}
async function Re(n, e = !1) {
  var t, r;
  if (!J())
    throw new Error("WebAuthn is not supported in this browser");
  let s;
  ((t = n.allowCredentials) === null || t === void 0 ? void 0 : t.length) !== 0 && (s = (r = n.allowCredentials) === null || r === void 0 ? void 0 : r.map(ee));
  const i = {
    ...n,
    challenge: q(n.challenge),
    allowCredentials: s
  }, c = {};
  if (e) {
    if (!await Ie())
      throw Error("Browser does not support WebAuthn autofill");
    if (document.querySelectorAll("input[autocomplete*='webauthn']").length < 1)
      throw Error('No <input> with `"webauthn"` in its `autocomplete` attribute was detected');
    c.mediation = "conditional", i.allowCredentials = [];
  }
  c.publicKey = i, c.signal = U.createNewAbortSignal();
  let l;
  try {
    l = await navigator.credentials.get(c);
  } catch (d) {
    throw _e({ error: d, options: c });
  } finally {
    U.reset();
  }
  if (!l)
    throw new Error("Authentication was not completed");
  const { id: h, rawId: f, response: o, type: a } = l;
  let u;
  return o.userHandle && (u = Ae(o.userHandle)), {
    id: h,
    rawId: I(f),
    response: {
      authenticatorData: I(o.authenticatorData),
      clientDataJSON: I(o.clientDataJSON),
      signature: I(o.signature),
      userHandle: u
    },
    type: a,
    clientExtensionResults: l.getClientExtensionResults(),
    authenticatorAttachment: l.authenticatorAttachment
  };
}
const M = typeof window != "undefined", x = /* @__PURE__ */ new Map(), Oe = (n) => {
  var e;
  return M && typeof localStorage != "undefined" ? localStorage.getItem(n) : (e = x.get(n)) != null ? e : null;
}, be = (n, e) => {
  M && typeof localStorage != "undefined" ? e ? localStorage.setItem(n, e) : localStorage.removeItem(n) : e ? x.set(n, e) : x.has(n) && x.delete(n);
}, Pe = (n, e) => {
  if (n === "localStorage" || n === "web")
    return Oe;
  if (n === "cookie")
    return (t) => {
      var r;
      return M && (r = V.get(t)) != null ? r : null;
    };
  if (!e)
    throw Error(
      `clientStorageType is set to '${n}' but no clientStorage has been given`
    );
  if (n === "react-native")
    return (t) => {
      var r;
      return (r = e.getItem) == null ? void 0 : r.call(e, t);
    };
  if (n === "capacitor")
    return (t) => {
      var r;
      return (r = e.get) == null ? void 0 : r.call(e, { key: t });
    };
  if (n === "expo-secure-storage")
    return (t) => {
      var r;
      return (r = e.getItemAsync) == null ? void 0 : r.call(e, t);
    };
  if (n === "custom") {
    if (e.getItem && e.removeItem)
      return e.getItem;
    if (e.getItemAsync)
      return e.getItemAsync;
    throw Error(
      `clientStorageType is set to 'custom' but clientStorage is missing either "getItem" and "removeItem" properties or "getItemAsync" property`
    );
  }
  throw Error(`Unknown storage type: ${n}`);
}, Ce = (n, e) => {
  if (n === "localStorage" || n === "web")
    return be;
  if (n === "cookie")
    return (t, r) => {
      M && (r ? V.set(t, r, { expires: 30, sameSite: "lax", httpOnly: !1 }) : V.remove(t));
    };
  if (!e)
    throw Error(
      `clientStorageType is set to '${n}' but no clienStorage has been given`
    );
  if (n === "react-native")
    return (t, r) => {
      var s, i;
      return r ? (s = e.setItem) == null ? void 0 : s.call(e, t, r) : (i = e.removeItem) == null ? void 0 : i.call(e, t);
    };
  if (n === "capacitor")
    return (t, r) => {
      var s, i;
      return r ? (s = e.set) == null ? void 0 : s.call(e, { key: t, value: r }) : (i = e.remove) == null ? void 0 : i.call(e, { key: t });
    };
  if (n === "expo-secure-storage")
    return async (t, r) => {
      var s, i;
      return r ? (s = e.setItemAsync) == null ? void 0 : s.call(e, t, r) : (i = e.deleteItemAsync) == null ? void 0 : i.call(e, t);
    };
  if (n === "custom") {
    if (!e.removeItem)
      throw Error(
        "clientStorageType is set to 'custom' but clientStorage is missing a removeItem property"
      );
    if (e.setItem)
      return (t, r) => {
        var s, i;
        return r ? (s = e.setItem) == null ? void 0 : s.call(e, t, r) : (i = e.removeItem) == null ? void 0 : i.call(e, t);
      };
    if (e.setItemAsync)
      return async (t, r) => {
        var s, i;
        return r ? (s = e.setItemAsync) == null ? void 0 : s.call(e, t, r) : (i = e.removeItem) == null ? void 0 : i.call(e, t);
      };
    throw Error(
      "clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property"
    );
  }
  throw Error(`Unknown storage type: ${n}`);
}, C = (n) => !n || !n.accessToken.value || !n.refreshToken.value || !n.accessToken.expiresAt || !n.user ? null : {
  accessToken: n.accessToken.value,
  accessTokenExpiresIn: (n.accessToken.expiresAt.getTime() - Date.now()) / 1e3,
  refreshToken: n.refreshToken.value,
  user: n.user
}, A = ({
  accessToken: n,
  isError: e,
  user: t,
  error: r
}) => e ? {
  session: null,
  error: r
} : t && n ? {
  session: { accessToken: n, accessTokenExpiresIn: 0, refreshToken: "", user: t },
  error: null
} : { session: null, error: null }, L = () => typeof window != "undefined", ne = async (n, e, { token: t, body: r } = {}) => {
  const s = {
    "Content-Type": "application/json",
    Accept: "*/*"
  };
  t && (s.Authorization = `Bearer ${t}`);
  const i = {
    method: e,
    headers: s
  };
  r && (i.body = JSON.stringify(r));
  try {
    const c = await ce(n, i);
    if (!c.ok) {
      const l = await c.json();
      return Promise.reject({ error: l });
    }
    try {
      return { data: await c.json(), error: null };
    } catch {
      return console.warn(`Unexpected response: can't parse the response of the server at ${n}`), { data: "OK", error: null };
    }
  } catch {
    const l = {
      message: "Network Error",
      status: X,
      error: "network"
    };
    return Promise.reject({ error: l });
  }
}, k = async (n, e, t) => ne(n, "POST", { token: t, body: e }), Ne = (n, e) => ne(n, "GET", { token: e }), se = (n, e) => {
  const t = e && Object.entries(e).map(([r, s]) => {
    const i = Array.isArray(s) ? s.join(",") : typeof s == "object" ? JSON.stringify(s) : s;
    return `${r}=${encodeURIComponent(i)}`;
  }).join("&");
  return t ? `${n}?${t}` : n;
}, w = (n, e) => {
  if (!(e != null && e.redirectTo))
    return e;
  const { redirectTo: t, ...r } = e;
  if (!n)
    return t.startsWith("/") ? r : e;
  const s = new URL(n), i = Object.fromEntries(new URLSearchParams(s.search)), c = new URL(t.startsWith("/") ? s.origin + t : t), l = new URLSearchParams(c.search);
  let h = Object.fromEntries(l);
  t.startsWith("/") && (h = { ...i, ...h });
  let f = s.pathname;
  return c.pathname.length > 1 && (f += c.pathname.slice(1)), {
    ...r,
    redirectTo: se(c.origin + f, h)
  };
};
function N(n, e) {
  var s;
  if (!e) {
    if (typeof window == "undefined")
      return;
    e = ((s = window.location) == null ? void 0 : s.href) || "";
  }
  n = n.replace(/[\[\]]/g, "\\$&");
  const t = new RegExp("[?&#]" + n + "(=([^&#]*)|&|#|$)"), r = t.exec(e);
  return r ? r[2] ? decodeURIComponent(r[2].replace(/\+/g, " ")) : "" : null;
}
function Y(n) {
  var t;
  if (typeof window == "undefined")
    return;
  const e = window == null ? void 0 : window.location;
  if (e && e) {
    const r = new URLSearchParams(e.search), s = new URLSearchParams((t = e.hash) == null ? void 0 : t.slice(1));
    r.delete(n), s.delete(n);
    let i = window.location.pathname;
    Array.from(r).length && (i += `?${r.toString()}`), Array.from(s).length && (i += `#${s.toString()}`), window.history.pushState({}, "", i);
  }
}
const v = (n) => !!n && typeof n == "string" && !!String(n).toLowerCase().match(
  /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
), $ = (n) => !!n && typeof n == "string" && n.length >= ue, F = (n) => !!n && typeof n == "string", De = (n) => n && typeof n == "string" && n.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i), xe = ({
  backendUrl: n,
  clientUrl: e,
  clientStorageType: t = "web",
  clientStorage: r,
  refreshIntervalTime: s,
  autoRefreshToken: i = !0,
  autoSignIn: c = !0
}) => {
  const l = Pe(t, r), h = Ce(t, r), f = async (o, a, u) => (await k(`${n}${o}`, a, u)).data;
  return _(
    {
      schema: {
        context: {},
        events: {},
        services: {}
      },
      tsTypes: {},
      context: K,
      predictableActionArguments: !0,
      id: "nhost",
      type: "parallel",
      states: {
        authentication: {
          initial: "starting",
          on: {
            SESSION_UPDATE: [
              {
                cond: "hasSession",
                actions: ["saveSession", "resetTimer", "reportTokenChanged"],
                target: ".signedIn"
              }
            ]
          },
          states: {
            starting: {
              tags: ["loading"],
              always: { cond: "isSignedIn", target: "signedIn" },
              invoke: {
                id: "importRefreshToken",
                src: "importRefreshToken",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "signedIn"
                  },
                  {
                    target: "signedOut"
                  }
                ],
                onError: [
                  {
                    cond: "shouldRetryImportToken",
                    actions: "incrementTokenImportAttempts",
                    target: "retryTokenImport"
                  },
                  { actions: ["saveAuthenticationError"], target: "signedOut" }
                ]
              }
            },
            retryTokenImport: {
              tags: ["loading"],
              after: {
                RETRY_IMPORT_TOKEN_DELAY: "starting"
              }
            },
            signedOut: {
              initial: "noErrors",
              entry: "reportSignedOut",
              states: {
                noErrors: {},
                success: {},
                needsSmsOtp: {},
                needsMfa: {},
                failed: {},
                signingOut: {
                  entry: ["clearContextExceptRefreshToken"],
                  exit: ["destroyRefreshToken", "reportTokenChanged"],
                  invoke: {
                    src: "signout",
                    id: "signingOut",
                    onDone: {
                      target: "success"
                    },
                    onError: {
                      target: "failed",
                      actions: ["saveAuthenticationError"]
                    }
                  }
                }
              },
              on: {
                SIGNIN_PASSWORD: "authenticating.password",
                SIGNIN_ANONYMOUS: "authenticating.anonymous",
                SIGNIN_SECURITY_KEY_EMAIL: "authenticating.securityKeyEmail",
                SIGNIN_MFA_TOTP: "authenticating.mfa.totp"
              }
            },
            authenticating: {
              entry: "resetErrors",
              states: {
                password: {
                  invoke: {
                    src: "signInPassword",
                    id: "authenticateUserWithPassword",
                    onDone: [
                      {
                        cond: "hasMfaTicket",
                        actions: ["saveMfaTicket"],
                        target: "#nhost.authentication.signedOut.needsMfa"
                      },
                      {
                        actions: ["saveSession", "reportTokenChanged"],
                        target: "#nhost.authentication.signedIn"
                      }
                    ],
                    onError: [
                      {
                        cond: "unverified",
                        target: [
                          "#nhost.authentication.signedOut",
                          "#nhost.registration.incomplete.needsEmailVerification"
                        ]
                      },
                      {
                        actions: "saveAuthenticationError",
                        target: "#nhost.authentication.signedOut.failed"
                      }
                    ]
                  }
                },
                anonymous: {
                  invoke: {
                    src: "signInAnonymous",
                    id: "authenticateAnonymously",
                    onDone: {
                      actions: ["saveSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: {
                      actions: "saveAuthenticationError",
                      target: "#nhost.authentication.signedOut.failed"
                    }
                  }
                },
                mfa: {
                  states: {
                    totp: {
                      invoke: {
                        src: "signInMfaTotp",
                        id: "signInMfaTotp",
                        onDone: {
                          actions: ["saveSession", "reportTokenChanged"],
                          target: "#nhost.authentication.signedIn"
                        },
                        onError: {
                          actions: ["saveAuthenticationError"],
                          target: "#nhost.authentication.signedOut.failed"
                        }
                      }
                    }
                  }
                },
                securityKeyEmail: {
                  invoke: {
                    src: "signInSecurityKeyEmail",
                    id: "authenticateUserWithSecurityKey",
                    onDone: {
                      actions: ["saveSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: [
                      {
                        cond: "unverified",
                        target: [
                          "#nhost.authentication.signedOut",
                          "#nhost.registration.incomplete.needsEmailVerification"
                        ]
                      },
                      {
                        actions: "saveAuthenticationError",
                        target: "#nhost.authentication.signedOut.failed"
                      }
                    ]
                  }
                }
              }
            },
            signedIn: {
              type: "parallel",
              entry: ["reportSignedIn", "cleanUrl", "broadcastToken", "resetErrors"],
              on: {
                SIGNOUT: "signedOut.signingOut"
              },
              states: {
                refreshTimer: {
                  id: "timer",
                  initial: "idle",
                  states: {
                    disabled: { type: "final" },
                    stopped: {
                      always: {
                        cond: "noToken",
                        target: "idle"
                      }
                    },
                    idle: {
                      always: [
                        { cond: "isAutoRefreshDisabled", target: "disabled" },
                        {
                          cond: "hasRefreshToken",
                          target: "running"
                        }
                      ]
                    },
                    running: {
                      initial: "pending",
                      entry: "resetTimer",
                      states: {
                        pending: {
                          after: {
                            1e3: {
                              internal: !1,
                              target: "pending"
                            }
                          },
                          always: {
                            cond: "refreshTimerShouldRefresh",
                            target: "refreshing"
                          }
                        },
                        refreshing: {
                          invoke: {
                            src: "refreshToken",
                            id: "refreshToken",
                            onDone: {
                              actions: ["saveSession", "resetTimer", "reportTokenChanged"],
                              target: "pending"
                            },
                            onError: [{ actions: "saveRefreshAttempt", target: "pending" }]
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        token: {
          initial: "idle",
          states: {
            idle: {
              on: {
                TRY_TOKEN: "running"
              },
              initial: "noErrors",
              states: { noErrors: {}, error: {} }
            },
            running: {
              invoke: {
                src: "refreshToken",
                id: "authenticateWithToken",
                onDone: {
                  actions: ["saveSession", "reportTokenChanged"],
                  target: ["#nhost.authentication.signedIn", "idle.noErrors"]
                },
                onError: [
                  { cond: "isSignedIn", target: "idle.error" },
                  {
                    actions: "saveAuthenticationError",
                    target: ["#nhost.authentication.signedOut.failed", "idle.error"]
                  }
                ]
              }
            }
          }
        },
        registration: {
          initial: "incomplete",
          on: {
            SIGNED_IN: [{ cond: "isAnonymous", target: ".incomplete" }, ".complete"]
          },
          states: {
            incomplete: {
              on: {
                SIGNUP_EMAIL_PASSWORD: "emailPassword",
                SIGNUP_SECURITY_KEY: "securityKey",
                PASSWORDLESS_EMAIL: "passwordlessEmail",
                PASSWORDLESS_SMS: "passwordlessSms",
                PASSWORDLESS_SMS_OTP: "passwordlessSmsOtp"
              },
              initial: "noErrors",
              states: {
                noErrors: {},
                needsEmailVerification: {},
                needsOtp: {},
                failed: {}
              }
            },
            emailPassword: {
              entry: ["resetErrors"],
              invoke: {
                src: "signUpEmailPassword",
                id: "signUpEmailPassword",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "#nhost.authentication.signedIn"
                  },
                  {
                    actions: "clearContext",
                    target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                  }
                ],
                onError: [
                  {
                    cond: "unverified",
                    target: "incomplete.needsEmailVerification"
                  },
                  {
                    actions: "saveRegistrationError",
                    target: "incomplete.failed"
                  }
                ]
              }
            },
            securityKey: {
              entry: ["resetErrors"],
              invoke: {
                src: "signUpSecurityKey",
                id: "signUpSecurityKey",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "#nhost.authentication.signedIn"
                  },
                  {
                    actions: "clearContext",
                    target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                  }
                ],
                onError: [
                  {
                    cond: "unverified",
                    target: "incomplete.needsEmailVerification"
                  },
                  {
                    actions: "saveRegistrationError",
                    target: "incomplete.failed"
                  }
                ]
              }
            },
            passwordlessEmail: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessEmail",
                id: "passwordlessEmail",
                onDone: {
                  actions: "clearContext",
                  target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            passwordlessSms: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessSms",
                id: "passwordlessSms",
                onDone: {
                  actions: "clearContext",
                  target: ["#nhost.authentication.signedOut", "incomplete.needsOtp"]
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            passwordlessSmsOtp: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessSmsOtp",
                id: "passwordlessSmsOtp",
                onDone: {
                  actions: ["saveSession", "reportTokenChanged"],
                  target: "#nhost.authentication.signedIn"
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            complete: {
              on: {
                SIGNED_OUT: "incomplete"
              }
            }
          }
        }
      }
    },
    {
      actions: {
        reportSignedIn: p("SIGNED_IN"),
        reportSignedOut: p("SIGNED_OUT"),
        reportTokenChanged: p("TOKEN_CHANGED"),
        incrementTokenImportAttempts: m({
          importTokenAttempts: ({ importTokenAttempts: o }) => o + 1
        }),
        clearContext: m(() => (h(P, null), h(b, null), {
          ...K
        })),
        clearContextExceptRefreshToken: m(({ refreshToken: { value: o } }) => (h(P, null), {
          ...K,
          refreshToken: { value: o }
        })),
        saveSession: m({
          user: (o, { data: a }) => {
            var u;
            return ((u = a == null ? void 0 : a.session) == null ? void 0 : u.user) || null;
          },
          accessToken: (o, { data: a }) => {
            if (a.session) {
              const { accessTokenExpiresIn: u, accessToken: d } = a.session, E = new Date(Date.now() + u * 1e3);
              return h(P, E.toISOString()), {
                value: d,
                expiresAt: E
              };
            }
            return h(P, null), {
              value: null,
              expiresAt: null
            };
          },
          refreshToken: (o, { data: a }) => {
            var d;
            const u = ((d = a.session) == null ? void 0 : d.refreshToken) || null;
            return u && h(b, u), { value: u };
          }
        }),
        saveMfaTicket: m({
          mfa: (o, a) => {
            var u;
            return (u = a.data) == null ? void 0 : u.mfa;
          }
        }),
        resetTimer: m({
          refreshTimer: (o) => ({
            startedAt: new Date(),
            attempts: 0,
            lastAttempt: null
          })
        }),
        saveRefreshAttempt: m({
          refreshTimer: (o, a) => ({
            startedAt: o.refreshTimer.startedAt,
            attempts: o.refreshTimer.attempts + 1,
            lastAttempt: new Date()
          })
        }),
        saveAuthenticationError: m({
          errors: ({ errors: o }, { data: { error: a } }) => ({
            ...o,
            authentication: a
          })
        }),
        resetErrors: m({
          errors: (o) => ({}),
          importTokenAttempts: (o) => 0
        }),
        saveRegistrationError: m({
          errors: ({ errors: o }, { data: { error: a } }) => ({ ...o, registration: a })
        }),
        destroyRefreshToken: m({
          refreshToken: (o) => (h(b, null), { value: null })
        }),
        cleanUrl: () => {
          c && N("refreshToken") && (Y("refreshToken"), Y("type"));
        },
        broadcastToken: (o) => {
          if (c)
            try {
              new BroadcastChannel("nhost").postMessage(o.refreshToken.value);
            } catch {
            }
        }
      },
      guards: {
        isAnonymous: (o, a) => {
          var u;
          return !!((u = o.user) != null && u.isAnonymous);
        },
        isSignedIn: (o) => !!o.user && !!o.refreshToken.value && !!o.accessToken.value,
        noToken: (o) => !o.refreshToken.value,
        hasRefreshToken: (o) => !!o.refreshToken.value,
        isAutoRefreshDisabled: () => !i,
        refreshTimerShouldRefresh: (o) => {
          const { expiresAt: a } = o.accessToken;
          return a ? o.refreshTimer.lastAttempt ? o.refreshTimer.attempts > j ? !1 : Date.now() - o.refreshTimer.lastAttempt.getTime() > Math.pow(2, o.refreshTimer.attempts - 1) * 5e3 : s && Date.now() - o.refreshTimer.startedAt.getTime() > s * 1e3 ? !0 : a.getTime() - Date.now() - 1e3 * le <= 0 : !1;
        },
        shouldRetryImportToken: (o, a) => o.importTokenAttempts < j && (a.data.error.status === X || a.data.error.status >= 500),
        unverified: (o, { data: { error: a } }) => a.status === 401 && (a.message === "Email is not verified" || a.error === "unverified-user"),
        hasSession: (o, a) => {
          var u;
          return !!((u = a.data) != null && u.session);
        },
        hasMfaTicket: (o, a) => {
          var u;
          return !!((u = a.data) != null && u.mfa);
        }
      },
      services: {
        signInPassword: (o, { email: a, password: u }) => v(a) ? $(u) ? f("/signin/email-password", {
          email: a,
          password: u
        }) : Promise.reject({ error: G }) : Promise.reject({ error: S }),
        passwordlessSms: (o, { phoneNumber: a, options: u }) => {
          var d;
          return F(a) ? (d = o.user) != null && d.isAnonymous ? (console.warn(
            "Deanonymisation from a phone number is not yet implemented in hasura-auth"
          ), f(
            "/user/deanonymize",
            {
              signInMethod: "passwordless",
              connection: "sms",
              phoneNumber: a,
              options: w(e, u)
            },
            o.accessToken.value
          )) : f("/signin/passwordless/sms", {
            phoneNumber: a,
            options: w(e, u)
          }) : Promise.reject({ error: H });
        },
        passwordlessSmsOtp: (o, { phoneNumber: a, otp: u }) => F(a) ? f("/signin/passwordless/sms/otp", {
          phoneNumber: a,
          otp: u
        }) : Promise.reject({ error: H }),
        passwordlessEmail: (o, { email: a, options: u }) => {
          var d;
          return v(a) ? (d = o.user) != null && d.isAnonymous ? f(
            "/user/deanonymize",
            {
              signInMethod: "passwordless",
              connection: "email",
              email: a,
              options: w(e, u)
            },
            o.accessToken.value
          ) : f("/signin/passwordless/email", {
            email: a,
            options: w(e, u)
          }) : Promise.reject({ error: S });
        },
        signInAnonymous: (o) => f("/signin/anonymous"),
        signInMfaTotp: (o, a) => {
          var d;
          const u = a.ticket || ((d = o.mfa) == null ? void 0 : d.ticket);
          return u ? De(u) ? f("/signin/mfa/totp", {
            ticket: u,
            otp: a.otp
          }) : Promise.reject({ error: he }) : Promise.reject({ error: me });
        },
        signInSecurityKeyEmail: async (o, { email: a }) => {
          if (!v(a))
            throw new D(S);
          const u = await f(
            "/signin/webauthn",
            { email: a }
          );
          let d;
          try {
            d = await Re(u);
          } catch (E) {
            throw new D(E);
          }
          return f("/signin/webauthn/verify", { email: a, credential: d });
        },
        refreshToken: async (o, a) => {
          const u = a.type === "TRY_TOKEN" ? a.token : o.refreshToken.value;
          return { session: await f("/token", {
            refreshToken: u
          }), error: null };
        },
        signout: (o, a) => f("/signout", {
          refreshToken: o.refreshToken.value,
          all: !!a.all
        }),
        signUpEmailPassword: async (o, { email: a, password: u, options: d }) => {
          var E;
          return v(a) ? $(u) ? (E = o.user) != null && E.isAnonymous ? f(
            "/user/deanonymize",
            {
              signInMethod: "email-password",
              email: a,
              password: u,
              options: w(e, d)
            },
            o.accessToken.value
          ) : f("/signup/email-password", {
            email: a,
            password: u,
            options: w(e, d)
          }) : Promise.reject({ error: G }) : Promise.reject({ error: S });
        },
        signUpSecurityKey: async (o, { email: a, options: u }) => {
          if (!v(a))
            return Promise.reject({ error: S });
          const d = u == null ? void 0 : u.nickname;
          d && delete u.nickname;
          const E = await f(
            "/signup/webauthn",
            { email: a, options: u }
          );
          let W;
          try {
            W = await te(E);
          } catch (oe) {
            throw new D(oe);
          }
          return f("/signup/webauthn/verify", {
            credential: W,
            options: {
              redirectTo: u == null ? void 0 : u.redirectTo,
              nickname: d
            }
          });
        },
        importRefreshToken: async (o) => {
          if (o.user && o.refreshToken.value && o.accessToken.value && o.accessToken.expiresAt)
            return {
              session: {
                accessToken: o.accessToken.value,
                accessTokenExpiresIn: o.accessToken.expiresAt.getTime() - Date.now(),
                refreshToken: o.refreshToken.value,
                user: o.user
              },
              error: null
            };
          let a = null;
          if (c) {
            const d = N("refreshToken") || null;
            if (d)
              try {
                return { session: await f("/token", {
                  refreshToken: d
                }), error: null };
              } catch (E) {
                a = E.error;
              }
            else {
              const E = N("error");
              if (E)
                return Promise.reject({
                  session: null,
                  error: {
                    status: T,
                    error: E,
                    message: N("errorDescription") || E
                  }
                });
            }
          }
          const u = await l(b);
          if (u)
            try {
              return { session: await f("/token", {
                refreshToken: u
              }), error: null };
            } catch (d) {
              a = d.error;
            }
          return a ? Promise.reject({ error: a, session: null }) : { error: null, session: null };
        }
      },
      delays: {
        RETRY_IMPORT_TOKEN_DELAY: ({ importTokenAttempts: o }) => Math.pow(2, o - 1) * 5e3
      }
    }
  );
}, Ue = ({ backendUrl: n, clientUrl: e, interpreter: t }) => _(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: !0,
    id: "changeEmail",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidEmailError: m({ error: (r) => S }),
      saveRequestError: m({
        error: (r, { data: { error: s } }) => s
      }),
      reportError: p((r) => ({ type: "ERROR", error: r.error })),
      reportSuccess: p("SUCCESS")
    },
    guards: {
      invalidEmail: (r, { email: s }) => !v(s)
    },
    services: {
      requestChange: async (r, { email: s, options: i }) => (await k(
        `${n}/user/email/change`,
        { newEmail: s, options: w(e, i) },
        t == null ? void 0 : t.getSnapshot().context.accessToken.value
      )).data
    }
  }
), Me = ({ backendUrl: n, interpreter: e }) => _(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: !0,
    id: "changePassword",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidPassword",
              actions: "saveInvalidPasswordError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidPasswordError: m({ error: (t) => G }),
      saveRequestError: m({
        error: (t, { data: { error: r } }) => r
      }),
      reportError: p((t) => ({ type: "ERROR", error: t.error })),
      reportSuccess: p("SUCCESS")
    },
    guards: {
      invalidPassword: (t, { password: r }) => !$(r)
    },
    services: {
      requestChange: (t, { password: r, ticket: s }) => k(
        `${n}/user/password`,
        { newPassword: r, ticket: s },
        e == null ? void 0 : e.getSnapshot().context.accessToken.value
      )
    }
  }
), nr = ({ backendUrl: n, interpreter: e }) => _(
  {
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    predictableActionArguments: !0,
    id: "enableMfa",
    initial: "idle",
    context: { error: null, imageUrl: null, secret: null },
    states: {
      idle: {
        initial: "initial",
        on: {
          GENERATE: "generating"
        },
        states: {
          initial: {},
          error: {}
        }
      },
      generating: {
        invoke: {
          src: "generate",
          id: "generate",
          onDone: { target: "generated", actions: ["reportGeneratedSuccess", "saveGeneration"] },
          onError: { actions: ["saveError", "reportGeneratedError"], target: "idle.error" }
        }
      },
      generated: {
        initial: "idle",
        states: {
          idle: {
            initial: "idle",
            on: {
              ACTIVATE: [
                {
                  cond: "invalidMfaType",
                  actions: "saveInvalidMfaTypeError",
                  target: ".error"
                },
                {
                  cond: "invalidMfaCode",
                  actions: "saveInvalidMfaCodeError",
                  target: ".error"
                },
                {
                  target: "activating"
                }
              ]
            },
            states: { idle: {}, error: {} }
          },
          activating: {
            invoke: {
              src: "activate",
              id: "activate",
              onDone: { target: "activated", actions: "reportSuccess" },
              onError: { actions: ["saveError", "reportError"], target: "idle.error" }
            }
          },
          activated: { type: "final" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidMfaTypeError: m({ error: (t) => de }),
      saveInvalidMfaCodeError: m({ error: (t) => fe }),
      saveError: m({
        error: (t, { data: { error: r } }) => r
      }),
      saveGeneration: m({
        imageUrl: (t, { data: { imageUrl: r } }) => r,
        secret: (t, { data: { totpSecret: r } }) => r
      }),
      reportError: p((t, r) => (console.log("REPORT", t, r), { type: "ERROR", error: t.error })),
      reportSuccess: p("SUCCESS"),
      reportGeneratedSuccess: p("GENERATED"),
      reportGeneratedError: p((t) => ({ type: "GENERATED_ERROR", error: t.error }))
    },
    guards: {
      invalidMfaCode: (t, { code: r }) => !r,
      invalidMfaType: (t, { activeMfaType: r }) => !r || r !== "totp"
    },
    services: {
      generate: async (t) => {
        const { data: r } = await Ne(
          `${n}/mfa/totp/generate`,
          e == null ? void 0 : e.getSnapshot().context.accessToken.value
        );
        return r;
      },
      activate: (t, { code: r, activeMfaType: s }) => k(
        `${n}/user/mfa`,
        { code: r, activeMfaType: s },
        e == null ? void 0 : e.getSnapshot().context.accessToken.value
      )
    }
  }
), Ke = ({ backendUrl: n, clientUrl: e }) => _(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: !0,
    id: "changePassword",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidEmailError: m({ error: (t) => S }),
      saveRequestError: m({
        error: (t, { data: { error: r } }) => r
      }),
      reportError: p((t) => ({ type: "ERROR", error: t.error })),
      reportSuccess: p("SUCCESS")
    },
    guards: {
      invalidEmail: (t, { email: r }) => !v(r)
    },
    services: {
      requestChange: (t, { email: r, options: s }) => k(`${n}/user/password/reset`, {
        email: r,
        options: w(e, s)
      })
    }
  }
), Ve = ({ backendUrl: n, clientUrl: e }) => _(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: !0,
    id: "sendVerificationEmail",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "request",
          id: "request",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidEmailError: m({ error: (t) => S }),
      saveRequestError: m({
        error: (t, { data: { error: r } }) => r
      }),
      reportError: p((t) => ({ type: "ERROR", error: t.error })),
      reportSuccess: p("SUCCESS")
    },
    guards: {
      invalidEmail: (t, { email: r }) => !v(r)
    },
    services: {
      request: async (t, { email: r, options: s }) => (await k(
        `${n}/user/email/send-verification-email`,
        { email: r, options: w(e, s) }
      )).data
    }
  }
);
class ie {
  constructor({
    clientStorageType: e = "web",
    autoSignIn: t = !0,
    autoRefreshToken: r = !0,
    start: s = !0,
    backendUrl: i,
    clientUrl: c,
    devTools: l,
    ...h
  }) {
    if (this._started = !1, this._subscriptionsQueue = /* @__PURE__ */ new Set(), this._subscriptions = /* @__PURE__ */ new Set(), this.backendUrl = i, this.clientUrl = c, this._machine = xe({
      ...h,
      backendUrl: i,
      clientUrl: c,
      clientStorageType: e,
      autoSignIn: t,
      autoRefreshToken: r
    }), s && this.start({ devTools: l }), typeof window != "undefined" && t)
      try {
        this._channel = new BroadcastChannel("nhost"), this._channel.addEventListener("message", (f) => {
          var a;
          const o = (a = this.interpreter) == null ? void 0 : a.getSnapshot().context.refreshToken.value;
          this.interpreter && f.data !== o && this.interpreter.send("TRY_TOKEN", { token: f.data });
        });
      } catch {
      }
  }
  start({
    devTools: e = !1,
    initialSession: t,
    interpreter: r
  } = {}) {
    var c, l;
    const s = { ...this.machine.context };
    t && (s.user = t.user, s.refreshToken.value = (c = t.refreshToken) != null ? c : null, s.accessToken.value = (l = t.accessToken) != null ? l : null, s.accessToken.expiresAt = new Date(
      Date.now() + t.accessTokenExpiresIn * 1e3
    ));
    const i = this.machine.withContext(s);
    this._interpreter || (this._interpreter = r || R(i, { devTools: e })), (!this._started || typeof window == "undefined") && (this._interpreter.initialized && (this._interpreter.stop(), this._subscriptions.forEach((h) => h())), this._interpreter.start(i.initialState), this._subscriptionsQueue.forEach((h) => h(this))), this._started = !0;
  }
  get machine() {
    return this._machine;
  }
  get interpreter() {
    return this._interpreter;
  }
  get started() {
    return this._started;
  }
  subscribe(e) {
    if (this.started) {
      const t = e(this);
      return this._subscriptions.add(t), t;
    } else
      return this._subscriptionsQueue.add(e), () => {
        console.log(
          "onTokenChanged was added before the interpreter started. Cannot unsubscribe listener."
        );
      };
  }
}
class Ge extends ie {
  constructor({
    ...e
  }) {
    super({
      ...e,
      autoSignIn: L() && e.autoSignIn,
      autoRefreshToken: L() && e.autoRefreshToken,
      clientStorageType: "cookie"
    });
  }
}
const sr = Ge, Le = async ({ backendUrl: n, interpreter: e }, t) => {
  try {
    const { data: r } = await k(
      `${n}/user/webauthn/add`,
      {},
      e == null ? void 0 : e.getSnapshot().context.accessToken.value
    );
    let s;
    try {
      s = await te(r);
    } catch (c) {
      throw new D(c);
    }
    const { data: i } = await k(
      `${n}/user/webauthn/verify`,
      { credential: s, nickname: t },
      e == null ? void 0 : e.getSnapshot().context.accessToken.value
    );
    return { key: i, isError: !1, error: null, isSuccess: !0 };
  } catch (r) {
    const { error: s } = r;
    return { isError: !0, error: s, isSuccess: !1 };
  }
}, $e = async (n, e, t) => new Promise((r) => {
  n.send("REQUEST", {
    email: e,
    options: t
  }), n.onTransition((s) => {
    s.matches({ idle: "error" }) ? r({ error: s.context.error, isError: !0, needsEmailVerification: !1 }) : s.matches({ idle: "success" }) && r({ error: null, isError: !1, needsEmailVerification: !0 });
  });
}), qe = async (n, e, t) => new Promise((r) => {
  n.send("REQUEST", {
    password: e,
    ticket: t
  }), n.onTransition((s) => {
    s.matches({ idle: "error" }) ? r({ error: s.context.error, isError: !0, isSuccess: !1 }) : s.matches({ idle: "success" }) && r({ error: null, isError: !1, isSuccess: !0 });
  });
}), ir = (n) => new Promise((e) => {
  n.send("GENERATE"), n.onTransition((t) => {
    t.matches("generated") ? e({
      error: null,
      isError: !1,
      isGenerated: !0,
      qrCodeDataUrl: t.context.imageUrl || ""
    }) : t.matches({ idle: "error" }) && e({
      error: t.context.error || null,
      isError: !0,
      isGenerated: !1,
      qrCodeDataUrl: ""
    });
  });
}), or = (n, e) => new Promise((t) => {
  n.send("ACTIVATE", {
    activeMfaType: "totp",
    code: e
  }), n.onTransition((r) => {
    r.matches({ generated: "activated" }) ? t({ error: null, isActivated: !0, isError: !1 }) : r.matches({ generated: { idle: "error" } }) && t({ error: r.context.error, isActivated: !1, isError: !0 });
  });
}), We = async (n, e, t) => new Promise((r) => {
  n.send("REQUEST", {
    email: e,
    options: t
  }), n.onTransition((s) => {
    s.matches({ idle: "error" }) ? r({ error: s.context.error, isError: !0, isSent: !1 }) : s.matches({ idle: "success" }) && r({ error: null, isError: !1, isSent: !0 });
  });
}), je = (n, e, t) => new Promise((r) => {
  n.send("REQUEST", {
    email: e,
    options: t
  }), n.onTransition((s) => {
    s.matches({ idle: "error" }) ? r({ error: s.context.error, isError: !0, isSent: !1 }) : s.matches({ idle: "success" }) && r({ error: null, isError: !1, isSent: !0 });
  });
}), He = (n) => new Promise((e) => {
  const { changed: t } = n.send("SIGNIN_ANONYMOUS");
  t || e({
    isSuccess: !1,
    isError: !0,
    error: y,
    user: null,
    accessToken: null
  }), n.onTransition((r) => {
    r.matches({ authentication: "signedIn" }) && e({
      isSuccess: !0,
      isError: !1,
      error: null,
      user: r.context.user,
      accessToken: r.context.accessToken.value
    }), r.matches({ authentication: { signedOut: "failed" } }) && e({
      isSuccess: !1,
      isError: !0,
      error: r.context.errors.authentication || null,
      user: null,
      accessToken: null
    });
  });
}), Ye = (n, e, t) => new Promise((r) => {
  const { changed: s, context: i } = n.send("SIGNIN_PASSWORD", {
    email: e,
    password: t
  });
  if (!s)
    return r({
      accessToken: i.accessToken.value,
      error: y,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      needsMfaOtp: !1,
      mfa: null,
      user: i.user
    });
  n.onTransition((c) => {
    c.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? r({
      accessToken: null,
      error: null,
      isError: !1,
      isSuccess: !1,
      needsEmailVerification: !0,
      needsMfaOtp: !1,
      mfa: null,
      user: null
    }) : c.matches({ authentication: { signedOut: "needsMfa" } }) ? r({
      accessToken: null,
      error: null,
      isError: !1,
      isSuccess: !1,
      needsEmailVerification: !1,
      needsMfaOtp: !0,
      mfa: c.context.mfa,
      user: null
    }) : c.matches({ authentication: { signedOut: "failed" } }) ? r({
      accessToken: null,
      error: c.context.errors.authentication || null,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      needsMfaOtp: !1,
      mfa: null,
      user: null
    }) : c.matches({ authentication: "signedIn" }) && r({
      accessToken: c.context.accessToken.value,
      error: null,
      isError: !1,
      isSuccess: !0,
      needsEmailVerification: !1,
      needsMfaOtp: !1,
      mfa: null,
      user: c.context.user
    });
  });
}), z = (n, e, t) => new Promise((r) => {
  const { changed: s } = n.send("PASSWORDLESS_EMAIL", {
    email: e,
    options: t
  });
  if (!s)
    return r({
      error: y,
      isError: !0,
      isSuccess: !1
    });
  n.onTransition((i) => {
    i.matches("registration.incomplete.failed") ? r({
      error: i.context.errors.registration || null,
      isError: !0,
      isSuccess: !1
    }) : i.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) && r({ error: null, isError: !1, isSuccess: !0 });
  });
}), Fe = (n, e) => new Promise((t) => {
  const { changed: r, context: s } = n.send({ type: "SIGNIN_SECURITY_KEY_EMAIL", email: e });
  if (!r)
    return t({
      accessToken: s.accessToken.value,
      error: y,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: s.user
    });
  n.onTransition((i) => {
    i.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? t({
      accessToken: null,
      error: null,
      isError: !1,
      isSuccess: !1,
      needsEmailVerification: !0,
      user: null
    }) : i.matches({ authentication: { signedOut: "failed" } }) ? t({
      accessToken: null,
      error: i.context.errors.authentication || null,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: null
    }) : i.matches({ authentication: "signedIn" }) && t({
      accessToken: i.context.accessToken.value,
      error: null,
      isError: !1,
      isSuccess: !0,
      needsEmailVerification: !1,
      user: i.context.user
    });
  });
}), ze = (n, e, t) => new Promise((r) => {
  const { changed: s, context: i } = n.send("SIGNIN_MFA_TOTP", {
    otp: e,
    ticket: t
  });
  if (!s)
    return r({
      accessToken: i.accessToken.value,
      error: y,
      isError: !0,
      isSuccess: !1,
      user: i.user
    });
  n.onTransition((c) => {
    c.matches({ authentication: { signedOut: "failed" } }) ? r({
      accessToken: null,
      error: c.context.errors.authentication || null,
      isError: !0,
      isSuccess: !1,
      user: null
    }) : c.matches({ authentication: "signedIn" }) && r({
      accessToken: c.context.accessToken.value,
      error: null,
      isError: !1,
      isSuccess: !0,
      user: c.context.user
    });
  });
}), Q = (n, e, t) => new Promise((r) => {
  const { changed: s } = n.send("PASSWORDLESS_SMS", { phoneNumber: e, options: t });
  if (!s)
    return r({
      error: y,
      isError: !0,
      isSuccess: !1,
      needsOtp: !1
    });
  n.onTransition((i) => {
    i.matches("registration.incomplete.needsOtp") ? r({
      error: null,
      isError: !1,
      isSuccess: !1,
      needsOtp: !0
    }) : i.matches("registration.incomplete.failed") && r({
      error: i.context.errors.authentication || null,
      isError: !0,
      isSuccess: !1,
      needsOtp: !1
    });
  });
}), Qe = (n, e, t) => new Promise((r) => {
  const { changed: s } = n.send({ type: "PASSWORDLESS_SMS_OTP", phoneNumber: e, otp: t });
  if (!s)
    return r({
      error: y,
      isError: !0,
      isSuccess: !1,
      user: null,
      accessToken: null
    });
  n.onTransition((i) => {
    i.matches({ authentication: "signedIn" }) ? r({
      error: null,
      isError: !1,
      isSuccess: !0,
      user: i.context.user,
      accessToken: i.context.accessToken.value
    }) : i.matches({ registration: { incomplete: "failed" } }) && r({
      error: i.context.errors.authentication || null,
      isError: !0,
      isSuccess: !1,
      user: null,
      accessToken: null
    });
  });
}), Be = async (n, e) => new Promise((t) => {
  const { event: r } = n.send("SIGNOUT", { all: e });
  if (r.type !== "SIGNED_OUT")
    return t({ isSuccess: !1, isError: !0, error: pe });
  n.onTransition((s) => {
    s.matches({ authentication: { signedOut: "success" } }) ? t({ isSuccess: !0, isError: !1, error: null }) : s.matches("authentication.signedOut.failed") && t({ isSuccess: !1, isError: !0, error: s.context.errors.signout || null });
  });
}), B = (n, e, t, r) => new Promise((s) => {
  const { changed: i, context: c } = n.send("SIGNUP_EMAIL_PASSWORD", {
    email: e,
    password: t,
    options: r
  });
  if (!i)
    return s({
      error: y,
      accessToken: c.accessToken.value,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: c.user
    });
  n.onTransition((l) => {
    l.matches("registration.incomplete.failed") ? s({
      accessToken: null,
      error: l.context.errors.registration || null,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: null
    }) : l.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? s({
      accessToken: null,
      error: null,
      isError: !1,
      isSuccess: !1,
      needsEmailVerification: !0,
      user: null
    }) : l.matches({ authentication: "signedIn", registration: "complete" }) && s({
      accessToken: l.context.accessToken.value,
      error: null,
      isError: !1,
      isSuccess: !0,
      needsEmailVerification: !1,
      user: l.context.user
    });
  });
}), Xe = (n, e, t) => new Promise((r) => {
  const { changed: s, context: i } = n.send("SIGNUP_SECURITY_KEY", {
    email: e,
    options: t
  });
  if (!s)
    return r({
      error: y,
      accessToken: i.accessToken.value,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: i.user
    });
  n.onTransition((c) => {
    c.matches("registration.incomplete.failed") ? r({
      accessToken: null,
      error: c.context.errors.registration || null,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: null
    }) : c.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? r({
      accessToken: null,
      error: null,
      isError: !1,
      isSuccess: !1,
      needsEmailVerification: !0,
      user: null
    }) : c.matches({ authentication: "signedIn", registration: "complete" }) && r({
      accessToken: c.context.accessToken.value,
      error: null,
      isError: !1,
      isSuccess: !0,
      needsEmailVerification: !1,
      user: c.context.user
    });
  });
});
class ar {
  constructor({
    url: e,
    autoRefreshToken: t = !0,
    autoSignIn: r = !0,
    clientStorage: s,
    clientStorageType: i,
    refreshIntervalTime: c,
    start: l = !0
  }) {
    var h;
    this.url = e, this._client = new ie({
      backendUrl: e,
      clientUrl: typeof window != "undefined" && ((h = window.location) == null ? void 0 : h.origin) || "",
      autoRefreshToken: t,
      autoSignIn: r,
      start: l,
      clientStorage: s,
      clientStorageType: i,
      refreshIntervalTime: c
    });
  }
  async signUp(e) {
    const t = await this.waitUntilReady(), { email: r, options: s } = e;
    return "securityKey" in e ? A(
      await Xe(t, r, s)
    ) : A(
      await B(t, r, e.password, s)
    );
  }
  async signIn(e) {
    const t = await this.waitUntilReady();
    if (!e) {
      const r = await He(t);
      return { ...A(r), mfa: null };
    }
    if ("provider" in e) {
      const { provider: r, options: s } = e, i = se(
        `${this._client.backendUrl}/signin/provider/${r}`,
        w(this._client.clientUrl, s)
      );
      return L() && (window.location.href = i), { providerUrl: i, provider: r, session: null, mfa: null, error: null };
    }
    if ("email" in e && "password" in e) {
      const r = await Ye(t, e.email, e.password);
      return r.needsEmailVerification ? { session: null, mfa: null, error: we } : r.needsMfaOtp ? {
        session: null,
        mfa: r.mfa,
        error: null
      } : { ...A(r), mfa: null };
    }
    if ("email" in e && "securityKey" in e) {
      if (e.securityKey !== !0)
        throw Error("securityKey must be true");
      const r = await Fe(t, e.email);
      return { ...A(r), mfa: null };
    }
    if ("email" in e) {
      const { email: r, options: s } = e, { error: i } = await z(t, r, s);
      return {
        session: null,
        mfa: null,
        error: i
      };
    }
    if ("phoneNumber" in e && "otp" in e) {
      const r = await Qe(t, e.phoneNumber, e.otp);
      return { ...A(r), mfa: null };
    }
    if ("phoneNumber" in e) {
      const { error: r } = await Q(
        t,
        e.phoneNumber,
        e.options
      );
      return { error: r, mfa: null, session: null };
    }
    if ("otp" in e) {
      const r = await ze(t, e.otp, e.ticket);
      return { ...A(r), mfa: null };
    }
    return { error: ye, mfa: null, session: null };
  }
  async signOut(e) {
    const t = await this.waitUntilReady(), { error: r } = await Be(t, e == null ? void 0 : e.all);
    return { error: r };
  }
  async resetPassword({ email: e, options: t }) {
    const r = R(Ke(this._client)).start(), { error: s } = await We(r, e, t);
    return { error: s };
  }
  async changePassword({
    newPassword: e,
    ticket: t
  }) {
    const r = R(Me(this._client)).start(), { error: s } = await qe(r, e, t);
    return { error: s };
  }
  async sendVerificationEmail({
    email: e,
    options: t
  }) {
    const r = R(Ve(this._client)).start(), { error: s } = await je(r, e, t);
    return { error: s };
  }
  async changeEmail({ newEmail: e, options: t }) {
    const r = R(Ue(this._client)).start(), { error: s } = await $e(r, e, t);
    return { error: s };
  }
  async deanonymize(e) {
    const t = await this.waitUntilReady();
    if (e.signInMethod === "passwordless") {
      if (e.connection === "email") {
        const { error: r } = await z(
          t,
          e.email,
          e.options
        );
        return { error: r };
      }
      if (e.connection === "sms") {
        const { error: r } = await Q(
          t,
          e.phoneNumber,
          e.options
        );
        return { error: r };
      }
    }
    if (e.signInMethod === "email-password") {
      const { error: r } = await B(
        t,
        e.email,
        e.password,
        e.options
      );
      return { error: r };
    }
    throw Error("Unknown deanonymization method");
  }
  async addSecurityKey(e) {
    const { error: t, key: r } = await Le(this._client, e);
    return { error: t, key: r };
  }
  onTokenChanged(e) {
    return this._client.subscribe(() => {
      var r;
      const t = (r = this._client.interpreter) == null ? void 0 : r.onTransition(({ event: s, context: i }) => {
        s.type === "TOKEN_CHANGED" && e(C(i));
      });
      return () => t == null ? void 0 : t.stop();
    });
  }
  onAuthStateChanged(e) {
    return this._client.subscribe(() => {
      var r;
      const t = (r = this._client.interpreter) == null ? void 0 : r.onTransition(({ event: s, context: i }) => {
        (s.type === "SIGNED_IN" || s.type === "SIGNED_OUT") && e(s.type, C(i));
      });
      return () => t == null ? void 0 : t.stop();
    });
  }
  isAuthenticated() {
    var e;
    return !!((e = this._client.interpreter) != null && e.getSnapshot().matches({ authentication: "signedIn" }));
  }
  async isAuthenticatedAsync() {
    return (await this.waitUntilReady()).getSnapshot().matches({ authentication: "signedIn" });
  }
  getAuthenticationStatus() {
    var t;
    const e = ((t = this.client.interpreter) == null ? void 0 : t.getSnapshot().context.importTokenAttempts) || 0;
    return this.isReady() ? { isAuthenticated: this.isAuthenticated(), isLoading: !1, connectionAttempts: e } : {
      isAuthenticated: !1,
      isLoading: !0,
      connectionAttempts: e
    };
  }
  getAccessToken() {
    var e, t;
    return (t = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot().context.accessToken.value) != null ? t : void 0;
  }
  getDecodedAccessToken() {
    const e = this.getAccessToken();
    return e ? ae(e) : null;
  }
  getHasuraClaims() {
    var e;
    return ((e = this.getDecodedAccessToken()) == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
  }
  getHasuraClaim(e) {
    var t;
    return ((t = this.getHasuraClaims()) == null ? void 0 : t[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
  }
  async refreshSession(e) {
    try {
      const t = await this.waitUntilReady();
      return new Promise((r) => {
        const s = e || t.getSnapshot().context.refreshToken.value;
        if (!s)
          return r({ session: null, error: Ee });
        const { changed: i } = t.send("TRY_TOKEN", { token: s });
        if (!i)
          return r({ session: null, error: ge });
        t.onTransition((c) => {
          c.matches({ token: { idle: "error" } }) ? r({
            session: null,
            error: Te
          }) : c.event.type === "TOKEN_CHANGED" && r({ session: C(c.context), error: null });
        });
      });
    } catch (t) {
      return { session: null, error: t.message };
    }
  }
  getSession() {
    var e, t;
    return C((t = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : t.context);
  }
  getUser() {
    var e, t, r;
    return ((r = (t = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : t.context) == null ? void 0 : r.user) || null;
  }
  waitUntilReady() {
    const t = this._client.interpreter;
    if (!t)
      throw Error("Auth interpreter not set");
    return t.getSnapshot().hasTag("loading") ? new Promise((r, s) => {
      let i = setTimeout(
        () => s(`The state machine is not yet ready after ${15} seconds.`),
        15e3
      );
      t.onTransition((c) => {
        if (!c.hasTag("loading"))
          return clearTimeout(i), r(t);
      });
    }) : Promise.resolve(t);
  }
  isReady() {
    var e, t;
    return !((t = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) != null && t.hasTag("loading"));
  }
  get client() {
    return this._client;
  }
}
export {
  ie as AuthClient,
  sr as AuthClientSSR,
  Ge as AuthCookieClient,
  D as CodifiedError,
  we as EMAIL_NEEDS_VERIFICATION,
  ar as HasuraAuthClient,
  K as INITIAL_MACHINE_CONTEXT,
  S as INVALID_EMAIL_ERROR,
  fe as INVALID_MFA_CODE_ERROR,
  he as INVALID_MFA_TICKET_ERROR,
  de as INVALID_MFA_TYPE_ERROR,
  G as INVALID_PASSWORD_ERROR,
  H as INVALID_PHONE_NUMBER_ERROR,
  Te as INVALID_REFRESH_TOKEN,
  ye as INVALID_SIGN_IN_METHOD,
  ue as MIN_PASSWORD_LENGTH,
  X as NETWORK_ERROR_CODE,
  P as NHOST_JWT_EXPIRES_AT_KEY,
  b as NHOST_REFRESH_TOKEN_KEY,
  me as NO_MFA_TICKET_ERROR,
  Ee as NO_REFRESH_TOKEN,
  Z as OTHER_ERROR_CODE,
  j as REFRESH_TOKEN_MAX_ATTEMPTS,
  O as STATE_ERROR_CODE,
  ge as TOKEN_REFRESHER_RUNNING_ERROR,
  le as TOKEN_REFRESH_MARGIN,
  y as USER_ALREADY_SIGNED_IN,
  tr as USER_NOT_ANONYMOUS,
  pe as USER_UNAUTHENTICATED,
  T as VALIDATION_ERROR_CODE,
  or as activateMfaPromise,
  Le as addSecurityKeyPromise,
  $e as changeEmailPromise,
  qe as changePasswordPromise,
  xe as createAuthMachine,
  Ue as createChangeEmailMachine,
  Me as createChangePasswordMachine,
  nr as createEnableMfaMachine,
  Ke as createResetPasswordMachine,
  Ve as createSendVerificationEmailMachine,
  se as encodeQueryParameters,
  ir as generateQrCodePromise,
  A as getAuthenticationResult,
  Ne as getFetch,
  N as getParameterByName,
  C as getSession,
  L as isBrowser,
  v as isValidEmail,
  $ as isValidPassword,
  F as isValidPhoneNumber,
  De as isValidTicket,
  Pe as localStorageGetter,
  Ce as localStorageSetter,
  k as postFetch,
  Y as removeParameterFromWindow,
  We as resetPasswordPromise,
  w as rewriteRedirectTo,
  je as sendVerificationEmailPromise,
  He as signInAnonymousPromise,
  Ye as signInEmailPasswordPromise,
  z as signInEmailPasswordlessPromise,
  Fe as signInEmailSecurityKeyPromise,
  ze as signInMfaTotpPromise,
  Qe as signInSmsPasswordlessOtpPromise,
  Q as signInSmsPasswordlessPromise,
  Be as signOutPromise,
  B as signUpEmailPasswordPromise,
  Xe as signUpEmailSecurityKeyPromise
};
//# sourceMappingURL=index.esm.js.map
