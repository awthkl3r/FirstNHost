{"version":3,"file":"index.cjs.js","sources":["../src/constants.ts","../src/errors.ts","../src/machines/authentication/context.ts","../../../node_modules/.pnpm/@simplewebauthn+browser@6.0.0/node_modules/@simplewebauthn/browser/dist/bundle/index.js","../src/local-storage.ts","../src/utils/client-helpers.ts","../src/utils/environment.ts","../src/utils/fetch.ts","../src/utils/url.ts","../src/utils/validators.ts","../src/machines/authentication/machine.ts","../src/machines/change-email.ts","../src/machines/change-password.ts","../src/machines/enable-mfa.ts","../src/machines/reset-password.ts","../src/machines/send-verification-email.ts","../src/internal-client.ts","../src/promises/addSecurityKey.ts","../src/promises/changeEmail.ts","../src/promises/changePassword.ts","../src/promises/mfa.ts","../src/promises/resetPassword.ts","../src/promises/sendVerificationEmail.ts","../src/promises/signInAnonymous.ts","../src/promises/signInEmailPassword.ts","../src/promises/signInEmailPasswordless.ts","../src/promises/signInEmailSecurityKey.ts","../src/promises/signInMfaTotp.ts","../src/promises/signInSmsPasswordless.ts","../src/promises/signInSmsPasswordlessOtp.ts","../src/promises/signOut.ts","../src/promises/signUpEmailPassword.ts","../src/promises/signUpEmailSecurityKey.ts","../src/hasura-auth-client.ts"],"sourcesContent":["export const NHOST_REFRESH_TOKEN_KEY = 'nhostRefreshToken'\nexport const NHOST_JWT_EXPIRES_AT_KEY = 'nhostRefreshTokenExpiresAt'\n\nexport const MIN_PASSWORD_LENGTH = 3\n\n/**\n * Minimum time in seconds between now and the JWT expiration time before the JWT is refreshed\n * For instance, if set to 60, the client will refresh the JWT one minute before it expires\n */\nexport const TOKEN_REFRESH_MARGIN = 300 // five minutes\n\nexport const REFRESH_TOKEN_MAX_ATTEMPTS = 5\n","import { AuthErrorPayload } from './types'\n\nexport const NETWORK_ERROR_CODE = 0\nexport const OTHER_ERROR_CODE = 1\nexport const VALIDATION_ERROR_CODE = 10\nexport const STATE_ERROR_CODE = 20\n\n/**\n * @internal\n * Adds a standard error payload to any JS Error, or convert a standard error payload into a JS Error.\n * Allows xstate to use `throw` instead of `Promise.reject` to propagate errors.\n * See https://github.com/statelyai/xstate/issues/3037\n */\nexport class CodifiedError extends Error {\n  error: AuthErrorPayload\n  constructor(original: Error | AuthErrorPayload) {\n    super(original.message)\n    Error.captureStackTrace(this, this.constructor)\n    if (original instanceof Error) {\n      this.name = original.name\n      this.error = {\n        error: original.name,\n        status: OTHER_ERROR_CODE,\n        message: original.message\n      }\n    } else {\n      this.name = original.error\n      this.error = original\n    }\n  }\n}\n\nexport type ValidationAuthErrorPayload = AuthErrorPayload & { status: typeof VALIDATION_ERROR_CODE }\n\n// TODO share with hasura-auth\nexport const INVALID_EMAIL_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-email',\n  message: 'Email is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TYPE_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-type',\n  message: 'MFA type is invalid'\n}\n\nexport const INVALID_MFA_CODE_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-code',\n  message: 'MFA code is invalid'\n}\n\nexport const INVALID_PASSWORD_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-password',\n  message: 'Password is incorrectly formatted'\n}\n\nexport const INVALID_PHONE_NUMBER_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-phone-number',\n  message: 'Phone number is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TICKET_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-ticket',\n  message: 'MFA ticket is invalid'\n}\n\nexport const NO_MFA_TICKET_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-mfa-ticket',\n  message: 'No MFA ticket has been provided'\n}\n\nexport const NO_REFRESH_TOKEN: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-refresh-token',\n  message: 'No refresh token has been provided'\n}\n\nexport const TOKEN_REFRESHER_RUNNING_ERROR: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'refresher-already-running',\n  message:\n    'The token refresher is already running. You must wait until is has finished before submitting a new token.'\n}\n\nexport const USER_ALREADY_SIGNED_IN: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'already-signed-in',\n  message: 'User is already signed in'\n}\n\nexport const USER_UNAUTHENTICATED: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unauthenticated-user',\n  message: 'User is not authenticated'\n}\n\nexport const USER_NOT_ANONYMOUS: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'user-not-anonymous',\n  message: 'User is not anonymous'\n}\n\nexport const EMAIL_NEEDS_VERIFICATION: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unverified-user',\n  message: 'Email needs verification'\n}\n\nexport const INVALID_REFRESH_TOKEN: AuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-refresh-token',\n  message: 'Invalid or expired refresh token'\n}\n\nexport const INVALID_SIGN_IN_METHOD: AuthErrorPayload = {\n  status: OTHER_ERROR_CODE,\n  error: 'invalid-sign-in-method',\n  message: 'Invalid sign-in method'\n}\n","import { AuthErrorPayload, User } from '../../types'\n\nexport type StateErrorTypes = 'registration' | 'authentication' | 'signout'\n\nexport type AuthContext = {\n  user: User | null\n  mfa: {\n    ticket: string\n  } | null\n  accessToken: {\n    value: string | null\n    expiresAt: Date | null\n  }\n  refreshTimer: {\n    startedAt: Date | null\n    attempts: number\n    lastAttempt: Date | null\n  }\n  refreshToken: {\n    value: string | null\n  }\n  /** Number of times the user tried to get an access token from a refresh token but got a network error */\n  importTokenAttempts: number\n  errors: Partial<Record<StateErrorTypes, AuthErrorPayload>>\n}\n\nexport const INITIAL_MACHINE_CONTEXT: AuthContext = {\n  user: null,\n  mfa: null,\n  accessToken: {\n    value: null,\n    expiresAt: null\n  },\n  refreshTimer: {\n    startedAt: null,\n    attempts: 0,\n    lastAttempt: null\n  },\n  refreshToken: {\n    value: null\n  },\n  importTokenAttempts: 0,\n  errors: {}\n}\n","/* [@simplewebauthn/browser@6.0.0] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return ((window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor(message, name = 'WebAuthnError') {\n        super(message);\n        this.name = name;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    var _a, _b;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Registration ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            return new WebAuthnError('Discoverable credentials were required but no available authenticator supported it', 'ConstraintError');\n        }\n        else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === 'required') {\n            return new WebAuthnError('User verification was required but no available authenticator supported it', 'ConstraintError');\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError('The authenticator was previously registered', 'InvalidStateError');\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError('User clicked cancel, or the registration ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', 'NotSupportedError');\n        }\n        return new WebAuthnError('No available authenticator supported any of the specified pubKeyCredParams algorithms', 'NotSupportedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rp.id}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError('User ID was not between 1 and 64 characters', 'TypeError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new credential', 'UnknownError');\n    }\n    return error;\n}\n\nclass WebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            this.controller.abort();\n        }\n        this.controller = new AbortController();\n        return this.controller.signal;\n    }\n    reset() {\n        this.controller = undefined;\n    }\n}\nconst webauthnAbortService = new WebAuthnAbortService();\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    finally {\n        webauthnAbortService.reset();\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    const credentialJSON = {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n    if (typeof response.getTransports === 'function') {\n        credentialJSON.transports = response.getTransports();\n    }\n    return credentialJSON;\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nasync function browserSupportsWebAuthnAutofill() {\n    if (navigator.credentials.conditionalMediationSupported) {\n        return true;\n    }\n    const globalPublicKeyCredential = window.PublicKeyCredential;\n    return (globalPublicKeyCredential.isConditionalMediationAvailable !== undefined &&\n        globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    var _a;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Authentication ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        if ((_a = publicKey.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) {\n            return new WebAuthnError('No available authenticator recognized any of the allowed credentials', 'NotAllowedError');\n        }\n        return new WebAuthnError('User clicked cancel, or the authentication ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rpId}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new assertion signature', 'UnknownError');\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    var _a, _b;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n        allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    finally {\n        webauthnAbortService.reset();\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n}\n\nasync function platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return false;\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n","import Cookies from 'js-cookie'\n\nimport { ClientStorage, ClientStorageType, StorageGetter, StorageSetter } from './types'\n\nconst isBrowser = typeof window !== 'undefined'\n\nconst inMemoryLocalStorage: Map<string, string | null> = new Map()\n\nconst defaultClientStorageGetter: StorageGetter = (key) => {\n  if (isBrowser && typeof localStorage !== 'undefined') return localStorage.getItem(key)\n  else return inMemoryLocalStorage.get(key) ?? null\n}\n\nconst defaultClientStorageSetter: StorageSetter = (key, value) => {\n  if (isBrowser && typeof localStorage !== 'undefined') {\n    if (value) {\n      localStorage.setItem(key, value)\n    } else {\n      localStorage.removeItem(key)\n    }\n  } else {\n    if (value) {\n      inMemoryLocalStorage.set(key, value)\n    } else if (inMemoryLocalStorage.has(key)) {\n      inMemoryLocalStorage.delete(key)\n    }\n  }\n}\n\nexport const localStorageGetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageGetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageGetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key) => {\n      if (isBrowser) {\n        return Cookies.get(key) ?? null\n      } else {\n        return null\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clientStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key) => clientStorage.getItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key) => clientStorage.get?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return (key) => clientStorage.getItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (clientStorage.getItem && clientStorage.removeItem) {\n      return clientStorage.getItem\n    }\n    if (clientStorage.getItemAsync) {\n      return clientStorage.getItemAsync\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing either \"getItem\" and \"removeItem\" properties or \"getItemAsync\" property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n\nexport const localStorageSetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageSetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageSetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key, value) => {\n      if (isBrowser) {\n        if (value) {\n          // TODO: Set expires based on the actual refresh token expire time\n          // For now, we're using 30 days so the cookie is not removed when the browser is closed because if `expiers` is omitted, the cookie becomes a session cookie.\n          Cookies.set(key, value, { expires: 30, sameSite: 'lax', httpOnly: false })\n        } else {\n          Cookies.remove(key)\n        }\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clienStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key, value) =>\n      value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key, value) =>\n      value ? clientStorage.set?.({ key, value }) : clientStorage.remove?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return async (key, value) =>\n      value ? clientStorage.setItemAsync?.(key, value) : clientStorage.deleteItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (!clientStorage.removeItem) {\n      throw Error(\n        `clientStorageType is set to 'custom' but clientStorage is missing a removeItem property`\n      )\n    }\n    if (clientStorage.setItem) {\n      return (key, value) =>\n        value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    if (clientStorage.setItemAsync) {\n      return async (key, value) =>\n        value ? clientStorage.setItemAsync?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n","import { AuthContext } from '../machines'\nimport { SessionActionHandlerResult } from '../promises'\nimport { NhostSession, SignUpResponse } from '../types'\n\nexport const getSession = (context?: AuthContext): NhostSession | null => {\n  if (\n    !context ||\n    !context.accessToken.value ||\n    !context.refreshToken.value ||\n    !context.accessToken.expiresAt ||\n    !context.user\n  ) {\n    return null\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1000,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  }\n}\n\nexport const getAuthenticationResult = ({\n  accessToken,\n  isError,\n  user,\n  error\n}: SessionActionHandlerResult): SignUpResponse => {\n  if (isError) {\n    return {\n      session: null,\n      error\n    }\n  }\n  if (user && accessToken) {\n    return {\n      // TODO either return the refresh token or remove it from the session type\n      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: '', user },\n      error: null\n    }\n  }\n  return { session: null, error: null }\n}\n","export const isBrowser = () => typeof window !== 'undefined'\n","import fetch from 'isomorphic-unfetch'\nimport { NETWORK_ERROR_CODE } from '../errors'\nimport { NullableErrorResponse } from '../types'\n\ninterface FetcResponse<T> extends NullableErrorResponse {\n  data: T\n}\n\nconst fetchWrapper = async <T>(\n  url: string,\n  method: 'GET' | 'POST',\n  { token, body }: { token?: string | null; body?: any } = {}\n): Promise<FetcResponse<T>> => {\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json',\n    Accept: '*/*'\n  }\n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`\n  }\n  const options: RequestInit = {\n    method,\n    headers\n  }\n  if (body) {\n    options.body = JSON.stringify(body)\n  }\n  try {\n    const result = await fetch(url, options)\n    if (!result.ok) {\n      const error = await result.json()\n      return Promise.reject<FetcResponse<T>>({ error })\n    }\n    try {\n      const data = await result.json()\n      return { data, error: null }\n    } catch {\n      console.warn(`Unexpected response: can't parse the response of the server at ${url}`)\n      return { data: 'OK' as any, error: null }\n    }\n  } catch (e) {\n    const error = {\n      message: 'Network Error',\n      status: NETWORK_ERROR_CODE,\n      error: 'network'\n    }\n    return Promise.reject<FetcResponse<T>>({ error })\n  }\n}\n\nexport const postFetch = async <T>(\n  url: string,\n  body: any,\n  token?: string | null\n): Promise<FetcResponse<T>> => fetchWrapper<T>(url, 'POST', { token, body })\n\nexport const getFetch = <T>(url: string, token?: string | null): Promise<FetcResponse<T>> =>\n  fetchWrapper<T>(url, 'GET', { token })\n","import { RedirectOption } from '../types'\n\nexport const encodeQueryParameters = (baseUrl: string, parameters?: Record<string, unknown>) => {\n  const encodedParameters =\n    parameters &&\n    Object.entries(parameters)\n      .map(([key, value]) => {\n        const stringValue = Array.isArray(value)\n          ? value.join(',')\n          : typeof value === 'object'\n          ? JSON.stringify(value)\n          : (value as string)\n        return `${key}=${encodeURIComponent(stringValue)}`\n      })\n      .join('&')\n  if (encodedParameters) return `${baseUrl}?${encodedParameters}`\n  else return baseUrl\n}\n\n/**\n * Transform options that include a redirectTo property so the\n * redirect url is absolute, given a base clientUrl.\n * If no client url is given, any relative redirectUrl is removed while\n * the other options are sent as-is.\n * @param clientUrl base client url\n * @param options\n * @returns\n */\nexport const rewriteRedirectTo = <T extends RedirectOption>(\n  clientUrl?: string,\n  options?: T\n): (Omit<T, 'redirectTo'> & { redirectTo?: string }) | undefined => {\n  if (!options?.redirectTo) {\n    return options\n  }\n  const { redirectTo, ...otherOptions } = options\n  // * If the clientUrl is not defined, we can't rewrite the redirectTo\n  if (!clientUrl) {\n    // * If redirectTo is a relative path, we therefore pull it out of the options\n    if (redirectTo.startsWith('/')) {\n      return otherOptions\n    } else {\n      return options\n    }\n  }\n  const baseClientUrl = new URL(clientUrl)\n  const clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search))\n  const url = new URL(redirectTo.startsWith('/') ? baseClientUrl.origin + redirectTo : redirectTo)\n  const additionalParams = new URLSearchParams(url.search)\n  let combinedParams = Object.fromEntries(additionalParams)\n\n  if (redirectTo.startsWith('/')) {\n    combinedParams = { ...clientParams, ...combinedParams }\n  }\n  let pathName = baseClientUrl.pathname\n  if (url.pathname.length > 1) {\n    pathName += url.pathname.slice(1)\n  }\n  return {\n    ...otherOptions,\n    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)\n  }\n}\n\nexport function getParameterByName(name: string, url?: string) {\n  if (!url) {\n    if (typeof window === 'undefined') {\n      return\n    }\n    url = window.location?.href || ''\n  }\n  // eslint-disable-next-line no-useless-escape\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\n    results = regex.exec(url)\n  if (!results) return null\n  if (!results[2]) return ''\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\nexport function removeParameterFromWindow(name: string) {\n  if (typeof window === 'undefined') {\n    return\n  }\n  const location = window?.location\n  if (!location) {\n    return\n  }\n  if (location) {\n    const search = new URLSearchParams(location.search)\n    const hash = new URLSearchParams(location.hash?.slice(1))\n    search.delete(name)\n    hash.delete(name)\n    let url = window.location.pathname\n    if (Array.from(search).length) url += `?${search.toString()}`\n    if (Array.from(hash).length) url += `#${hash.toString()}`\n    window.history.pushState({}, '', url)\n  }\n}\n","import { MIN_PASSWORD_LENGTH } from '../constants'\n\nexport const isValidEmail = (email?: string | null) =>\n  !!email &&\n  typeof email === 'string' &&\n  !!String(email)\n    .toLowerCase()\n    .match(\n      /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n    )\n\nexport const isValidPassword = (password?: string | null) =>\n  !!password && typeof password === 'string' && password.length >= MIN_PASSWORD_LENGTH\n\n// TODO improve validation\nexport const isValidPhoneNumber = (phoneNumber?: string | null) =>\n  !!phoneNumber && typeof phoneNumber === 'string'\n\nexport const isValidTicket = (ticket?: string | null) =>\n  ticket &&\n  typeof ticket === 'string' &&\n  ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)\n","import { startAuthentication, startRegistration } from '@simplewebauthn/browser'\nimport type {\n  AuthenticationCredentialJSON,\n  PublicKeyCredentialCreationOptionsJSON,\n  PublicKeyCredentialRequestOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\nimport { assign, createMachine, InterpreterFrom, send } from 'xstate'\nimport {\n  NHOST_JWT_EXPIRES_AT_KEY,\n  NHOST_REFRESH_TOKEN_KEY,\n  REFRESH_TOKEN_MAX_ATTEMPTS,\n  TOKEN_REFRESH_MARGIN\n} from '../../constants'\nimport {\n  CodifiedError,\n  INVALID_EMAIL_ERROR,\n  INVALID_MFA_TICKET_ERROR,\n  INVALID_PASSWORD_ERROR,\n  INVALID_PHONE_NUMBER_ERROR,\n  NETWORK_ERROR_CODE,\n  NO_MFA_TICKET_ERROR,\n  VALIDATION_ERROR_CODE\n} from '../../errors'\nimport { localStorageGetter, localStorageSetter } from '../../local-storage'\nimport {\n  AuthErrorPayload,\n  AuthOptions,\n  DeanonymizeResponse,\n  NhostSession,\n  NhostSessionResponse,\n  PasswordlessEmailResponse,\n  PasswordlessSmsOtpResponse,\n  PasswordlessSmsResponse,\n  RefreshSessionResponse,\n  SignInAnonymousResponse,\n  SignInMfaTotpResponse,\n  SignInResponse,\n  SignOutResponse,\n  SignUpResponse\n} from '../../types'\nimport {\n  getParameterByName,\n  isValidEmail,\n  isValidPassword,\n  isValidPhoneNumber,\n  isValidTicket,\n  postFetch,\n  removeParameterFromWindow,\n  rewriteRedirectTo\n} from '../../utils'\nimport { AuthContext, INITIAL_MACHINE_CONTEXT } from './context'\nimport { AuthEvents } from './events'\n\nexport interface AuthMachineOptions extends AuthOptions {\n  backendUrl: string\n  clientUrl: string\n}\n\nexport type AuthMachine = ReturnType<typeof createAuthMachine>\nexport type AuthInterpreter = InterpreterFrom<AuthMachine>\n\ntype AuthServices = {\n  signInPassword: { data: SignInResponse }\n  passwordlessSms: { data: PasswordlessSmsResponse | DeanonymizeResponse }\n  passwordlessSmsOtp: { data: PasswordlessSmsOtpResponse }\n  passwordlessEmail: { data: PasswordlessEmailResponse | DeanonymizeResponse }\n  signInAnonymous: { data: SignInAnonymousResponse }\n  signInMfaTotp: { data: SignInMfaTotpResponse }\n  signInSecurityKeyEmail: { data: SignInResponse }\n  refreshToken: { data: NhostSessionResponse }\n  signout: { data: SignOutResponse }\n  signUpEmailPassword: { data: SignUpResponse }\n  signUpSecurityKey: { data: SignUpResponse }\n  importRefreshToken: { data: NhostSessionResponse }\n}\n\nexport const createAuthMachine = ({\n  backendUrl,\n  clientUrl,\n  clientStorageType = 'web',\n  clientStorage,\n  refreshIntervalTime,\n  autoRefreshToken = true,\n  autoSignIn = true\n}: AuthMachineOptions) => {\n  const storageGetter = localStorageGetter(clientStorageType, clientStorage)\n  const storageSetter = localStorageSetter(clientStorageType, clientStorage)\n  const postRequest = async <T = any, D = any>(\n    url: string,\n    data?: D,\n    token?: string | null\n  ): Promise<T> => {\n    const result = await postFetch<T>(`${backendUrl}${url}`, data, token)\n\n    return result.data\n  }\n  return createMachine(\n    {\n      schema: {\n        context: {} as AuthContext,\n        events: {} as AuthEvents,\n        services: {} as AuthServices\n      },\n      tsTypes: {} as import('./machine.typegen').Typegen0,\n      context: INITIAL_MACHINE_CONTEXT,\n      predictableActionArguments: true,\n      id: 'nhost',\n      type: 'parallel',\n      states: {\n        authentication: {\n          initial: 'starting',\n          on: {\n            SESSION_UPDATE: [\n              {\n                cond: 'hasSession',\n                actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                target: '.signedIn'\n              }\n            ]\n          },\n          states: {\n            starting: {\n              tags: ['loading'],\n              always: { cond: 'isSignedIn', target: 'signedIn' },\n              invoke: {\n                id: 'importRefreshToken',\n                src: 'importRefreshToken',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: 'signedIn'\n                  },\n                  {\n                    target: 'signedOut'\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'shouldRetryImportToken',\n                    actions: 'incrementTokenImportAttempts',\n                    target: 'retryTokenImport'\n                  },\n                  { actions: ['saveAuthenticationError'], target: 'signedOut' }\n                ]\n              }\n            },\n            retryTokenImport: {\n              tags: ['loading'],\n              after: {\n                RETRY_IMPORT_TOKEN_DELAY: 'starting'\n              }\n            },\n            signedOut: {\n              initial: 'noErrors',\n              entry: 'reportSignedOut',\n              states: {\n                noErrors: {},\n                success: {},\n                needsSmsOtp: {},\n                needsMfa: {},\n                failed: {},\n                signingOut: {\n                  entry: ['clearContextExceptRefreshToken'],\n                  exit: ['destroyRefreshToken', 'reportTokenChanged'],\n                  invoke: {\n                    src: 'signout',\n                    id: 'signingOut',\n                    onDone: {\n                      target: 'success'\n                    },\n                    onError: {\n                      target: 'failed',\n                      actions: ['saveAuthenticationError']\n                    }\n                  }\n                }\n              },\n              on: {\n                SIGNIN_PASSWORD: 'authenticating.password',\n                SIGNIN_ANONYMOUS: 'authenticating.anonymous',\n                SIGNIN_SECURITY_KEY_EMAIL: 'authenticating.securityKeyEmail',\n                SIGNIN_MFA_TOTP: 'authenticating.mfa.totp'\n              }\n            },\n            authenticating: {\n              entry: 'resetErrors',\n              states: {\n                password: {\n                  invoke: {\n                    src: 'signInPassword',\n                    id: 'authenticateUserWithPassword',\n                    onDone: [\n                      {\n                        cond: 'hasMfaTicket',\n                        actions: ['saveMfaTicket'],\n                        target: '#nhost.authentication.signedOut.needsMfa'\n                      },\n                      {\n                        actions: ['saveSession', 'reportTokenChanged'],\n                        target: '#nhost.authentication.signedIn'\n                      }\n                    ],\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                },\n                anonymous: {\n                  invoke: {\n                    src: 'signInAnonymous',\n                    id: 'authenticateAnonymously',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                mfa: {\n                  states: {\n                    totp: {\n                      invoke: {\n                        src: 'signInMfaTotp',\n                        id: 'signInMfaTotp',\n                        onDone: {\n                          actions: ['saveSession', 'reportTokenChanged'],\n                          target: '#nhost.authentication.signedIn'\n                        },\n                        onError: {\n                          actions: ['saveAuthenticationError'],\n                          target: '#nhost.authentication.signedOut.failed'\n                        }\n                      }\n                    }\n                  }\n                },\n                securityKeyEmail: {\n                  invoke: {\n                    src: 'signInSecurityKeyEmail',\n                    id: 'authenticateUserWithSecurityKey',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                }\n              }\n            },\n            signedIn: {\n              type: 'parallel',\n              entry: ['reportSignedIn', 'cleanUrl', 'broadcastToken', 'resetErrors'],\n              on: {\n                SIGNOUT: 'signedOut.signingOut'\n              },\n              states: {\n                refreshTimer: {\n                  id: 'timer',\n                  initial: 'idle',\n                  states: {\n                    disabled: { type: 'final' },\n                    stopped: {\n                      always: {\n                        cond: 'noToken',\n                        target: 'idle'\n                      }\n                    },\n                    idle: {\n                      always: [\n                        { cond: 'isAutoRefreshDisabled', target: 'disabled' },\n                        {\n                          cond: 'hasRefreshToken',\n                          target: 'running'\n                        }\n                      ]\n                    },\n                    running: {\n                      initial: 'pending',\n                      entry: 'resetTimer',\n                      states: {\n                        pending: {\n                          after: {\n                            '1000': {\n                              internal: false,\n                              target: 'pending'\n                            }\n                          },\n                          always: {\n                            cond: 'refreshTimerShouldRefresh',\n                            target: 'refreshing'\n                          }\n                        },\n                        refreshing: {\n                          invoke: {\n                            src: 'refreshToken',\n                            id: 'refreshToken',\n                            onDone: {\n                              actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                              target: 'pending'\n                            },\n                            onError: [{ actions: 'saveRefreshAttempt', target: 'pending' }]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        token: {\n          initial: 'idle',\n          states: {\n            idle: {\n              on: {\n                TRY_TOKEN: 'running'\n              },\n              initial: 'noErrors',\n              states: { noErrors: {}, error: {} }\n            },\n            running: {\n              invoke: {\n                src: 'refreshToken',\n                id: 'authenticateWithToken',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: ['#nhost.authentication.signedIn', 'idle.noErrors']\n                },\n                onError: [\n                  { cond: 'isSignedIn', target: 'idle.error' },\n                  {\n                    actions: 'saveAuthenticationError',\n                    target: ['#nhost.authentication.signedOut.failed', 'idle.error']\n                  }\n                ]\n              }\n            }\n          }\n        },\n        registration: {\n          initial: 'incomplete',\n          on: {\n            SIGNED_IN: [{ cond: 'isAnonymous', target: '.incomplete' }, '.complete']\n          },\n          states: {\n            incomplete: {\n              on: {\n                SIGNUP_EMAIL_PASSWORD: 'emailPassword',\n                SIGNUP_SECURITY_KEY: 'securityKey',\n                PASSWORDLESS_EMAIL: 'passwordlessEmail',\n                PASSWORDLESS_SMS: 'passwordlessSms',\n                PASSWORDLESS_SMS_OTP: 'passwordlessSmsOtp'\n              },\n              initial: 'noErrors',\n              states: {\n                noErrors: {},\n                needsEmailVerification: {},\n                needsOtp: {},\n                failed: {}\n              }\n            },\n            emailPassword: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpEmailPassword',\n                id: 'signUpEmailPassword',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            securityKey: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpSecurityKey',\n                id: 'signUpSecurityKey',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            passwordlessEmail: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessEmail',\n                id: 'passwordlessEmail',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSms: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSms',\n                id: 'passwordlessSms',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsOtp']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSmsOtp: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSmsOtp',\n                id: 'passwordlessSmsOtp',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: '#nhost.authentication.signedIn'\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n\n            complete: {\n              on: {\n                SIGNED_OUT: 'incomplete'\n              }\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        reportSignedIn: send('SIGNED_IN'),\n        reportSignedOut: send('SIGNED_OUT'),\n        reportTokenChanged: send('TOKEN_CHANGED'),\n        incrementTokenImportAttempts: assign({\n          importTokenAttempts: ({ importTokenAttempts }) => importTokenAttempts + 1\n        }),\n        clearContext: assign(() => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT\n          }\n        }),\n        clearContextExceptRefreshToken: assign(({ refreshToken: { value } }) => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT,\n            refreshToken: { value }\n          }\n        }),\n\n        // * Save session in the context, and persist the refresh token and the jwt expiration outside of the machine\n        saveSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n            return { value: refreshToken }\n          }\n        }),\n        saveMfaTicket: assign({\n          mfa: (_, e) => e.data?.mfa\n        }),\n\n        resetTimer: assign({\n          refreshTimer: (_) => ({\n            startedAt: new Date(),\n            attempts: 0,\n            lastAttempt: null\n          })\n        }),\n\n        saveRefreshAttempt: assign({\n          refreshTimer: (ctx, e) => ({\n            startedAt: ctx.refreshTimer.startedAt,\n            attempts: ctx.refreshTimer.attempts + 1,\n            lastAttempt: new Date()\n          })\n        }),\n\n        // * Authentication errors\n        saveAuthenticationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({\n            ...errors,\n            authentication: error\n          })\n        }),\n        resetErrors: assign({\n          errors: (_) => ({}),\n          importTokenAttempts: (_) => 0\n        }),\n        saveRegistrationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({ ...errors, registration: error })\n        }),\n        destroyRefreshToken: assign({\n          refreshToken: (_) => {\n            storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n            return { value: null }\n          }\n        }),\n\n        // * Clean the browser url when `autoSignIn` is activated\n        cleanUrl: () => {\n          if (autoSignIn && getParameterByName('refreshToken')) {\n            // * Remove the refresh token from the URL\n            removeParameterFromWindow('refreshToken')\n            removeParameterFromWindow('type')\n          }\n        },\n\n        // * Broadcast the token to other tabs when `autoSignIn` is activated\n        broadcastToken: (context) => {\n          if (autoSignIn) {\n            try {\n              const channel = new BroadcastChannel('nhost')\n              // ? broadcat session instead of token ?\n              channel.postMessage(context.refreshToken.value)\n            } catch (error) {\n              // * BroadcastChannel is not available e.g. react-native\n            }\n          }\n        }\n      },\n\n      guards: {\n        isAnonymous: (ctx, e) => !!ctx.user?.isAnonymous,\n        isSignedIn: (ctx) => !!ctx.user && !!ctx.refreshToken.value && !!ctx.accessToken.value,\n        noToken: (ctx) => !ctx.refreshToken.value,\n        hasRefreshToken: (ctx) => !!ctx.refreshToken.value,\n        isAutoRefreshDisabled: () => !autoRefreshToken,\n        refreshTimerShouldRefresh: (ctx) => {\n          const { expiresAt } = ctx.accessToken\n          if (!expiresAt) {\n            return false\n          }\n          if (ctx.refreshTimer.lastAttempt) {\n            // * If the refresh timer reached the maximum number of attempts, we should not try again\n            if (ctx.refreshTimer.attempts > REFRESH_TOKEN_MAX_ATTEMPTS) {\n              return false\n            }\n            const elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime()\n            // * Exponential backoff\n            return elapsed > Math.pow(2, ctx.refreshTimer.attempts - 1) * 5_000\n          }\n          if (refreshIntervalTime) {\n            // * If a refreshIntervalTime has been passed on as an option, it will notify\n            // * the token should be refershed when this interval is overdue\n            const elapsed = Date.now() - ctx.refreshTimer.startedAt!.getTime()\n            if (elapsed > refreshIntervalTime * 1_000) {\n              return true\n            }\n          }\n          // * In any case, it's time to refresh when there's less than\n          // * TOKEN_REFRESH_MARGIN seconds before the JWT exprires\n          const expiresIn = expiresAt.getTime() - Date.now()\n          const remaining = expiresIn - 1_000 * TOKEN_REFRESH_MARGIN\n          return remaining <= 0\n        },\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        /** Shoud retry to import the token on network error or any internal server error.\n         * Don't retry more than REFRESH_TOKEN_MAX_ATTEMPTS times.\n         */\n        shouldRetryImportToken: (ctx, e: any) =>\n          ctx.importTokenAttempts < REFRESH_TOKEN_MAX_ATTEMPTS &&\n          (e.data.error.status === NETWORK_ERROR_CODE || e.data.error.status >= 500),\n        // * Authentication errors\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        unverified: (_, { data: { error } }: any) =>\n          error.status === 401 &&\n          // * legacy: don't use the message contents to determine if the email is unverified, but the error type (error.error)\n          (error.message === 'Email is not verified' || error.error === 'unverified-user'),\n\n        // * Event guards\n        hasSession: (_, e) => !!e.data?.session,\n        hasMfaTicket: (_, e) => !!e.data?.mfa\n      },\n\n      services: {\n        signInPassword: (_, { email, password }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject({ error: INVALID_PASSWORD_ERROR })\n          }\n          return postRequest<SignInResponse>('/signin/email-password', {\n            email,\n            password\n          })\n        },\n        passwordlessSms: (context, { phoneNumber, options }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            // TODO implement in hasura-auth\n            // * See https://github.com/nhost/hasura-auth/blob/9c6d0f4ded4fc8fd1b8031926c02796c74a7eada/src/routes/user/deanonymize.ts\n            console.warn(\n              'Deanonymisation from a phone number is not yet implemented in hasura-auth'\n            )\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'sms',\n                phoneNumber,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest('/signin/passwordless/sms', {\n              phoneNumber,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        passwordlessSmsOtp: (_, { phoneNumber, otp }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          return postRequest('/signin/passwordless/sms/otp', {\n            phoneNumber,\n            otp\n          })\n        },\n        passwordlessEmail: (context, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'email',\n                email,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest('/signin/passwordless/email', {\n              email,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signInAnonymous: (_) => postRequest('/signin/anonymous'),\n        signInMfaTotp: (context, data) => {\n          const ticket: string | undefined = data.ticket || context.mfa?.ticket\n          if (!ticket) {\n            return Promise.reject({ error: NO_MFA_TICKET_ERROR })\n          }\n          if (!isValidTicket(ticket)) {\n            return Promise.reject({ error: INVALID_MFA_TICKET_ERROR })\n          }\n\n          return postRequest('/signin/mfa/totp', {\n            ticket,\n            otp: data.otp\n          })\n        },\n        signInSecurityKeyEmail: async (_, { email }) => {\n          if (!isValidEmail(email)) {\n            throw new CodifiedError(INVALID_EMAIL_ERROR)\n          }\n          const options = await postRequest<PublicKeyCredentialRequestOptionsJSON>(\n            '/signin/webauthn',\n            { email }\n          )\n          let credential: AuthenticationCredentialJSON\n          try {\n            credential = await startAuthentication(options)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignInResponse>('/signin/webauthn/verify', { email, credential })\n        },\n        refreshToken: async (ctx, event) => {\n          const refreshToken = event.type === 'TRY_TOKEN' ? event.token : ctx.refreshToken.value\n          const session = await postRequest<RefreshSessionResponse>('/token', {\n            refreshToken\n          })\n          return { session, error: null }\n        },\n        signout: (ctx, e) =>\n          postRequest('/signout', {\n            refreshToken: ctx.refreshToken.value,\n            all: !!e.all\n          }),\n        signUpEmailPassword: async (context, { email, password, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_PASSWORD_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest<SignUpResponse>(\n              '/user/deanonymize',\n              {\n                signInMethod: 'email-password',\n                email,\n                password,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest<SignUpResponse>('/signup/email-password', {\n              email,\n              password,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signUpSecurityKey: async (_, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          // TODO anonymous users\n          const nickname = options?.nickname\n          /*\n           * The `/signup/webauthn` endpoint accepts any option from SignUpOptions,\n           * We therefore remove the nickname from the options object before sending it to the server,\n           * as options if of type `SignUpSecurityKeyOptions`, which extends `SignUpOptions` with the optional `nickname` property.\n           */\n          if (nickname) delete options.nickname\n          const webAuthnOptions = await postRequest<PublicKeyCredentialCreationOptionsJSON>(\n            '/signup/webauthn',\n            { email, options }\n          )\n          let credential: RegistrationCredentialJSON\n          try {\n            credential = await startRegistration(webAuthnOptions)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignUpResponse>('/signup/webauthn/verify', {\n            credential,\n            options: {\n              redirectTo: options?.redirectTo,\n              nickname\n            }\n          })\n        },\n        importRefreshToken: async (ctx) => {\n          if (\n            ctx.user &&\n            ctx.refreshToken.value &&\n            ctx.accessToken.value &&\n            ctx.accessToken.expiresAt\n          ) {\n            // * Do not import refresh token if the session already exists (loaded through initial state)\n            // TODO this should eventually be handled upstream in the state machine\n            return {\n              session: {\n                accessToken: ctx.accessToken.value,\n                accessTokenExpiresIn: ctx.accessToken.expiresAt.getTime() - Date.now(),\n                refreshToken: ctx.refreshToken.value,\n                user: ctx.user\n              },\n              error: null\n            }\n          }\n          let error: AuthErrorPayload | null = null\n          if (autoSignIn) {\n            const urlToken = getParameterByName('refreshToken') || null\n            if (urlToken) {\n              try {\n                const session = await postRequest<NhostSession>('/token', {\n                  refreshToken: urlToken\n                })\n                return { session, error: null }\n              } catch (exception) {\n                error = (exception as { error: AuthErrorPayload }).error\n              }\n            } else {\n              const error = getParameterByName('error')\n              if (error) {\n                return Promise.reject<NhostSessionResponse>({\n                  session: null,\n                  error: {\n                    status: VALIDATION_ERROR_CODE,\n                    error,\n                    message: getParameterByName('errorDescription') || error\n                  }\n                })\n              }\n            }\n          }\n          const storageToken = await storageGetter(NHOST_REFRESH_TOKEN_KEY)\n          if (storageToken) {\n            try {\n              const session = await postRequest<NhostSession>('/token', {\n                refreshToken: storageToken\n              })\n              return { session, error: null }\n            } catch (exception) {\n              error = (exception as { error: AuthErrorPayload }).error\n            }\n          }\n          if (error) {\n            return Promise.reject<NhostSessionResponse>({ error, session: null })\n          }\n          return { error: null, session: null }\n        }\n      },\n      delays: {\n        RETRY_IMPORT_TOKEN_DELAY: ({ importTokenAttempts }) => {\n          // * Exponential backoff\n          return Math.pow(2, importTokenAttempts - 1) * 5_000\n        }\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ChangeEmailOptions, ChangeEmailResponse } from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type ChangeEmailContext = {\n  error: AuthErrorPayload | null\n}\n\nexport type ChangeEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ChangeEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ChangeEmailServices = {\n  request: { data: ChangeEmailResponse }\n}\n\nexport type ChangeEmailMachine = ReturnType<typeof createChangeEmailMachine>\n\nexport const createChangeEmailMachine = ({ backendUrl, clientUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangeEmailContext,\n        events: {} as ChangeEmailEvents,\n        services: {} as ChangeEmailServices\n      },\n      tsTypes: {} as import('./change-email.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changeEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        // TODO change email in the main machine (context.user.email)\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: async (_, { email, options }) => {\n          const res = await postFetch(\n            `${backendUrl}/user/email/change`,\n            { newEmail: email, options: rewriteRedirectTo(clientUrl, options) },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_PASSWORD_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ChangePasswordResponse } from '../types'\nimport { postFetch } from '../utils'\nimport { isValidPassword } from '../utils/validators'\n\nexport type ChangePasswordContext = {\n  error: AuthErrorPayload | null\n}\nexport type ChangePasswordEvents =\n  | {\n      type: 'REQUEST'\n      password?: string\n      ticket?: string\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ChangePasswordServices = {\n  requestChange: { data: ChangePasswordResponse }\n}\n\nexport type ChangePasswordMachine = ReturnType<typeof createChangePasswordMachine>\n\nexport const createChangePasswordMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangePasswordContext,\n        events: {} as ChangePasswordEvents,\n        services: {} as ChangePasswordServices\n      },\n      tsTypes: {} as import('./change-password.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidPassword',\n                actions: 'saveInvalidPasswordError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidPasswordError: assign({ error: (_) => INVALID_PASSWORD_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidPassword: (_, { password }) => !isValidPassword(password)\n      },\n      services: {\n        requestChange: (_, { password, ticket }) =>\n          postFetch<ChangePasswordResponse>(\n            `${backendUrl}/user/password`,\n            { newPassword: password, ticket: ticket },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_MFA_CODE_ERROR, INVALID_MFA_TYPE_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload } from '../types'\nimport { getFetch, postFetch } from '../utils'\n\nexport type EnableMfaContext = {\n  error: AuthErrorPayload | null\n  imageUrl: string | null\n  secret: string | null\n}\n\nexport type EnableMfaEvents =\n  | {\n      type: 'GENERATE'\n    }\n  | {\n      type: 'ACTIVATE'\n      code?: string\n      activeMfaType: 'totp'\n    }\n  | { type: 'GENERATED' }\n  | { type: 'GENERATED_ERROR'; error: AuthErrorPayload | null }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type EnableMfadMachine = ReturnType<typeof createEnableMfaMachine>\n\nexport const createEnableMfaMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as EnableMfaContext,\n        events: {} as EnableMfaEvents\n      },\n      tsTypes: {} as import('./enable-mfa.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'enableMfa',\n      initial: 'idle',\n      context: { error: null, imageUrl: null, secret: null },\n      states: {\n        idle: {\n          initial: 'initial',\n          on: {\n            GENERATE: 'generating'\n          },\n          states: {\n            initial: {},\n            error: {}\n          }\n        },\n        generating: {\n          invoke: {\n            src: 'generate',\n            id: 'generate',\n            onDone: { target: 'generated', actions: ['reportGeneratedSuccess', 'saveGeneration'] },\n            onError: { actions: ['saveError', 'reportGeneratedError'], target: 'idle.error' }\n          }\n        },\n        generated: {\n          initial: 'idle',\n          states: {\n            idle: {\n              initial: 'idle',\n              on: {\n                ACTIVATE: [\n                  {\n                    cond: 'invalidMfaType',\n                    actions: 'saveInvalidMfaTypeError',\n                    target: '.error'\n                  },\n                  {\n                    cond: 'invalidMfaCode',\n                    actions: 'saveInvalidMfaCodeError',\n                    target: '.error'\n                  },\n                  {\n                    target: 'activating'\n                  }\n                ]\n              },\n              states: { idle: {}, error: {} }\n            },\n            activating: {\n              invoke: {\n                src: 'activate',\n                id: 'activate',\n                onDone: { target: 'activated', actions: 'reportSuccess' },\n                onError: { actions: ['saveError', 'reportError'], target: 'idle.error' }\n              }\n            },\n            activated: { type: 'final' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidMfaTypeError: assign({ error: (_) => INVALID_MFA_TYPE_ERROR }),\n        saveInvalidMfaCodeError: assign({ error: (_) => INVALID_MFA_CODE_ERROR }),\n        saveError: assign({\n          error: (_, { data: { error } }: any) => error\n        }),\n        saveGeneration: assign({\n          imageUrl: (_, { data: { imageUrl } }: any) => imageUrl,\n          secret: (_, { data: { totpSecret } }: any) => totpSecret\n        }),\n        reportError: send((ctx, event) => {\n          console.log('REPORT', ctx, event)\n          return { type: 'ERROR', error: ctx.error }\n        }),\n        reportSuccess: send('SUCCESS'),\n        reportGeneratedSuccess: send('GENERATED'),\n        reportGeneratedError: send((ctx) => ({ type: 'GENERATED_ERROR', error: ctx.error }))\n      },\n      guards: {\n        invalidMfaCode: (_, { code }) => !code,\n        invalidMfaType: (_, { activeMfaType }) => !activeMfaType || activeMfaType !== 'totp'\n      },\n      services: {\n        generate: async (_) => {\n          const { data } = await getFetch(\n            `${backendUrl}/mfa/totp/generate`,\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n          return data\n        },\n        activate: (_, { code, activeMfaType }) =>\n          postFetch(\n            `${backendUrl}/user/mfa`,\n            { code, activeMfaType },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ResetPasswordOptions, ResetPasswordResponse } from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type ResetPasswordContext = {\n  error: AuthErrorPayload | null\n}\nexport type ResetPasswordEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ResetPasswordOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ResetPasswordServices = {\n  requestChange: { data: ResetPasswordResponse }\n}\n\nexport type ResetPasswordMachine = ReturnType<typeof createResetPasswordMachine>\n\nexport const createResetPasswordMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ResetPasswordContext,\n        events: {} as ResetPasswordEvents,\n        services: {} as ResetPasswordServices\n      },\n      tsTypes: {} as import('./reset-password.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: (_, { email, options }) =>\n          postFetch<ResetPasswordResponse>(`${backendUrl}/user/password/reset`, {\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          })\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport {\n  AuthErrorPayload,\n  SendVerificationEmailOptions,\n  SendVerificationEmailResponse\n} from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type SendVerificationEmailContext = {\n  error: AuthErrorPayload | null\n}\n\nexport type SendVerificationEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: SendVerificationEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type SendVerificationEmailServices = {\n  request: { data: SendVerificationEmailResponse }\n}\n\nexport type SendVerificationEmailMachine = ReturnType<typeof createSendVerificationEmailMachine>\nexport const createSendVerificationEmailMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as SendVerificationEmailContext,\n        events: {} as SendVerificationEmailEvents,\n        services: {} as SendVerificationEmailServices\n      },\n      tsTypes: {} as import('./send-verification-email.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'sendVerificationEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'request',\n            id: 'request',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        request: async (_, { email, options }) => {\n          const res = await postFetch<SendVerificationEmailResponse>(\n            `${backendUrl}/user/email/send-verification-email`,\n            { email, options: rewriteRedirectTo(clientUrl, options) }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import { interpret } from 'xstate'\nimport { AuthInterpreter, AuthMachine, AuthMachineOptions, createAuthMachine } from './machines'\nimport { NhostSession } from './types'\nimport { isBrowser } from './utils'\n\nexport type NhostClientOptions = AuthMachineOptions & {\n  /** @internal create and start xstate interpreter on creation. With React, it is started inside the Nhost provider */\n  start?: boolean\n}\n\n/**\n * @internal\n * This is a private API.\n */\nexport class AuthClient {\n  readonly backendUrl: string\n  readonly clientUrl: string\n  private _machine: AuthMachine\n  private _interpreter?: AuthInterpreter\n  private _started = false\n  private _channel?: BroadcastChannel\n  private _subscriptionsQueue: Set<(client: AuthClient) => void> = new Set()\n  private _subscriptions: Set<() => void> = new Set()\n\n  constructor({\n    clientStorageType = 'web',\n    autoSignIn = true,\n    autoRefreshToken = true,\n    start = true,\n    backendUrl,\n    clientUrl,\n    devTools,\n    ...defaultOptions\n  }: NhostClientOptions) {\n    this.backendUrl = backendUrl\n    this.clientUrl = clientUrl\n\n    this._machine = createAuthMachine({\n      ...defaultOptions,\n      backendUrl,\n      clientUrl,\n      clientStorageType,\n      autoSignIn,\n      autoRefreshToken\n    })\n\n    if (start) {\n      this.start({ devTools })\n    }\n\n    if (typeof window !== 'undefined' && autoSignIn) {\n      try {\n        // TODO listen to sign out\n        // TODO the same refresh token is used and refreshed by all tabs\n        // * Ideally, a single tab should autorefresh and share the new jwt\n        this._channel = new BroadcastChannel('nhost')\n        this._channel.addEventListener('message', (token) => {\n          const existingToken = this.interpreter?.getSnapshot().context.refreshToken.value\n          if (this.interpreter && token.data !== existingToken) {\n            this.interpreter.send('TRY_TOKEN', { token: token.data })\n          }\n        })\n      } catch (error) {\n        // * BroadcastChannel is not available e.g. react-native\n      }\n    }\n  }\n\n  start({\n    devTools = false,\n    initialSession,\n    interpreter\n  }: { interpreter?: AuthInterpreter; initialSession?: NhostSession; devTools?: boolean } = {}) {\n    const context = { ...this.machine.context }\n    if (initialSession) {\n      context.user = initialSession.user\n      context.refreshToken.value = initialSession.refreshToken ?? null\n      context.accessToken.value = initialSession.accessToken ?? null\n      context.accessToken.expiresAt = new Date(\n        Date.now() + initialSession.accessTokenExpiresIn * 1_000\n      )\n    }\n    const machineWithInitialContext = this.machine.withContext(context)\n\n    if (!this._interpreter) {\n      this._interpreter = interpreter || interpret(machineWithInitialContext, { devTools })\n    }\n\n    // * Start the interpreter if not started already. Always restart the interpreter when on the server side\n    if (!this._started || typeof window === 'undefined') {\n      if (this._interpreter.initialized) {\n        this._interpreter.stop()\n        this._subscriptions.forEach((fn) => fn())\n      }\n      this._interpreter.start(machineWithInitialContext.initialState)\n      this._subscriptionsQueue.forEach((fn) => fn(this))\n    }\n\n    this._started = true\n  }\n\n  public get machine() {\n    return this._machine\n  }\n\n  get interpreter(): AuthInterpreter | undefined {\n    return this._interpreter\n  }\n\n  get started(): boolean {\n    return this._started\n  }\n\n  subscribe(fn: (client: AuthClient) => () => void): () => void {\n    if (this.started) {\n      // * The interpreter is already available: we can add the listener straight ahead\n      const subscription = fn(this)\n      this._subscriptions.add(subscription)\n      return subscription\n    } else {\n      // * The interpreter is not yet available: we add the listener to a queue that will be started when setting the interpreter\n      // * Note: in React, the Xstate interpreter does not start from the global state, but from the root component\n      this._subscriptionsQueue.add(fn)\n      return () => {\n        console.log(\n          'onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n}\n\n/** @deprecated Not in use anymore. Use `clientStorageType: 'cookie'` instead */\nexport class AuthCookieClient extends AuthClient {\n  constructor({\n    ...options\n  }: Omit<\n    NhostClientOptions,\n    'clientStorageGetter' | 'clientStorageSetter' | 'clientStorage' | 'clientStorageType'\n  >) {\n    super({\n      ...options,\n      autoSignIn: isBrowser() && options.autoSignIn,\n      autoRefreshToken: isBrowser() && options.autoRefreshToken,\n      clientStorageType: 'cookie'\n    })\n  }\n}\n\n/** @deprecated Alias for {@link AuthCookieClient} */\nexport const AuthClientSSR = AuthCookieClient\n","import { startRegistration } from '@simplewebauthn/browser'\nimport {\n  PublicKeyCredentialCreationOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\nimport { postFetch } from '..'\nimport { CodifiedError } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, SecurityKey } from '../types'\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface AddSecurityKeyHandlerResult extends AuthActionErrorState, AuthActionSuccessState {\n  key?: SecurityKey\n}\n\nexport interface AddSecurityKeyState extends AddSecurityKeyHandlerResult, AuthActionLoadingState {}\n\nexport const addSecurityKeyPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  nickname?: string\n): Promise<AddSecurityKeyHandlerResult> => {\n  try {\n    const { data: options } = await postFetch<PublicKeyCredentialCreationOptionsJSON>(\n      `${backendUrl}/user/webauthn/add`,\n      {},\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n    let credential: RegistrationCredentialJSON\n    try {\n      credential = await startRegistration(options)\n    } catch (e) {\n      throw new CodifiedError(e as Error)\n    }\n    const { data: key } = await postFetch<SecurityKey>(\n      `${backendUrl}/user/webauthn/verify`,\n      { credential, nickname },\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n    return { key, isError: false, error: null, isSuccess: true }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n    return { isError: true, error, isSuccess: false }\n  }\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangeEmailMachine } from '../machines'\nimport { ChangeEmailOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, NeedsEmailVerificationState } from './types'\nexport interface ChangeEmailHandlerResult\n  extends AuthActionErrorState,\n    NeedsEmailVerificationState {}\n\nexport interface ChangeEmailState extends ChangeEmailHandlerResult, AuthActionLoadingState {}\n\nexport const changeEmailPromise = async (\n  interpreter: InterpreterFrom<ChangeEmailMachine>,\n  email: string,\n  options?: ChangeEmailOptions\n): Promise<ChangeEmailHandlerResult> =>\n  new Promise<ChangeEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((s) => {\n      if (s.matches({ idle: 'error' })) {\n        resolve({ error: s.context.error, isError: true, needsEmailVerification: false })\n      } else if (s.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, needsEmailVerification: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangePasswordMachine } from '../machines'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface ChangePasswordState extends ChangePasswordHandlerResult, AuthActionLoadingState {}\n\nexport interface ChangePasswordHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\n\nexport const changePasswordPromise = async (\n  interpreter: InterpreterFrom<ChangePasswordMachine>,\n  password: string,\n  ticket?: string\n): Promise<ChangePasswordHandlerResult> =>\n  new Promise<ChangePasswordHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      password,\n      ticket\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSuccess: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { EnableMfadMachine } from '../machines'\n\nimport { AuthActionErrorState } from './types'\n\nexport interface GenerateQrCodeHandlerResult extends AuthActionErrorState {\n  qrCodeDataUrl: string\n  isGenerated: boolean\n}\n\nexport interface GenerateQrCodeState extends GenerateQrCodeHandlerResult {\n  isGenerating: boolean\n}\nexport interface ActivateMfaHandlerResult extends AuthActionErrorState {\n  isActivated: boolean\n}\n\nexport interface ActivateMfaState extends ActivateMfaHandlerResult {\n  isActivating: boolean\n}\n\nexport const generateQrCodePromise = (service: InterpreterFrom<EnableMfadMachine>) =>\n  new Promise<GenerateQrCodeHandlerResult>((resolve) => {\n    service.send('GENERATE')\n    service.onTransition((state) => {\n      if (state.matches('generated')) {\n        resolve({\n          error: null,\n          isError: false,\n          isGenerated: true,\n          qrCodeDataUrl: state.context.imageUrl || ''\n        })\n      } else if (state.matches({ idle: 'error' })) {\n        resolve({\n          error: state.context.error || null,\n          isError: true,\n          isGenerated: false,\n          qrCodeDataUrl: ''\n        })\n      }\n    })\n  })\nexport const activateMfaPromise = (service: InterpreterFrom<EnableMfadMachine>, code: string) =>\n  new Promise<ActivateMfaHandlerResult>((resolve) => {\n    service.send('ACTIVATE', {\n      activeMfaType: 'totp',\n      code\n    })\n    service.onTransition((state) => {\n      if (state.matches({ generated: 'activated' })) {\n        resolve({ error: null, isActivated: true, isError: false })\n      } else if (state.matches({ generated: { idle: 'error' } })) {\n        resolve({ error: state.context.error, isActivated: false, isError: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ResetPasswordMachine } from '../machines'\nimport { ResetPasswordOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState } from './types'\n\nexport interface ResetPasswordHandlerResult extends AuthActionErrorState {\n  /** Returns `true` when an email to reset the password has been sent */\n  isSent: boolean\n}\n\nexport interface ResetPasswordState extends ResetPasswordHandlerResult, AuthActionLoadingState {}\n\nexport const resetPasswordPromise = async (\n  interpreter: InterpreterFrom<ResetPasswordMachine>,\n  email: string,\n  options?: ResetPasswordOptions\n): Promise<ResetPasswordHandlerResult> =>\n  new Promise((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { SendVerificationEmailMachine } from '../machines'\nimport { SendVerificationEmailOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState } from './types'\n\nexport interface SendVerificationEmailHandlerResult extends AuthActionErrorState {\n  /** Returns `true` when a new verification email has been sent */\n  isSent: boolean\n}\n\nexport interface SendVerificationEmailState\n  extends AuthActionLoadingState,\n    SendVerificationEmailHandlerResult {}\n\nexport const sendVerificationEmailPromise = (\n  interpreter: InterpreterFrom<SendVerificationEmailMachine>,\n  email: string,\n  options?: SendVerificationEmailOptions\n): Promise<SendVerificationEmailHandlerResult> =>\n  new Promise<SendVerificationEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInAnonymousHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInAnonymousState\n  extends SignInAnonymousHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInAnonymousPromise = (\n  interpreter: AuthInterpreter\n): Promise<SignInAnonymousHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_ANONYMOUS')\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          isSuccess: true,\n          isError: false,\n          error: null,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        })\n      }\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          isSuccess: false,\n          isError: true,\n          error: state.context.errors.authentication || null,\n          user: null,\n          accessToken: null\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {\n  needsMfaOtp: boolean\n  mfa: {\n    ticket: string\n  } | null\n}\n\nexport interface SignInEmailPasswordState\n  extends SignInEmailPasswordHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string\n) =>\n  new Promise<SignInEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_PASSWORD', {\n      email,\n      password\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'needsMfa' } })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: true,\n          mfa: state.context.mfa,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { PasswordlessOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\nexport interface SignInEmailPasswordlessHandlerResult\n  extends AuthActionErrorState,\n    AuthActionSuccessState {}\nexport interface SignInEmailPasswordlessState\n  extends SignInEmailPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInEmailPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_EMAIL', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInSecurityKeyPasswordlessHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignInSecurityKeyPasswordlessState\n  extends SignInSecurityKeyPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailSecurityKeyPromise = (interpreter: AuthInterpreter, email: string) =>\n  new Promise<SignInSecurityKeyPasswordlessHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send({ type: 'SIGNIN_SECURITY_KEY_EMAIL', email })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInMfaTotpHandlerResult extends SessionActionHandlerResult {}\n\nexport interface SignInMfaTotpState extends SignInMfaTotpHandlerResult, AuthActionLoadingState {}\n\nexport const signInMfaTotpPromise = (interpreter: AuthInterpreter, otp: string, ticket?: string) =>\n  new Promise<SignInMfaTotpHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_MFA_TOTP', {\n      otp,\n      ticket\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { PasswordlessOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface SignInSmsPasswordlessState\n  extends SignInSmsPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport interface SignInSmsPasswordlessHandlerResult\n  extends AuthActionErrorState,\n    AuthActionSuccessState {\n  /**\n   * Returns true when the one-time password has been sent over by SMS, and the user needs to send it back to complete sign-in.\n   */\n  needsOtp: boolean\n}\n\nexport const signInSmsPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInSmsPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_SMS', { phoneNumber, options })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.needsOtp')) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsOtp: true\n        })\n      } else if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInSmsPasswordlessOtpHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInSmsPasswordlessOtpState\n  extends SignInSmsPasswordlessOtpHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInSmsPasswordlessOtpPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  otp: string\n) =>\n  new Promise<SignInSmsPasswordlessOtpHandlerResult>((resolve) => {\n    const { changed } = interpreter.send({ type: 'PASSWORDLESS_SMS_OTP', phoneNumber, otp })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        })\n      } else if (state.matches({ registration: { incomplete: 'failed' } })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null\n        })\n      }\n    })\n  })\n","import { USER_UNAUTHENTICATED } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface SignOutlessHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\nexport interface SignOutlessState extends SignOutlessHandlerResult, AuthActionLoadingState {}\n\nexport const signOutPromise = async (\n  interpreter: AuthInterpreter,\n  all?: boolean\n): Promise<SignOutlessHandlerResult> =>\n  new Promise<SignOutlessHandlerResult>((resolve) => {\n    const { event } = interpreter.send('SIGNOUT', { all })\n    if (event.type !== 'SIGNED_OUT') {\n      return resolve({ isSuccess: false, isError: true, error: USER_UNAUTHENTICATED })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'success' } })) {\n        resolve({ isSuccess: true, isError: false, error: null })\n      } else if (state.matches('authentication.signedOut.failed')) {\n        resolve({ isSuccess: false, isError: true, error: state.context.errors.signout || null })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { SignUpOptions } from '../types'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpEmailPasswordState\n  extends SignUpEmailPasswordHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signUpEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string,\n  options?: SignUpOptions\n): Promise<SignUpEmailPasswordHandlerResult> =>\n  new Promise<SignUpEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_EMAIL_PASSWORD', {\n      email,\n      password,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { SignUpSecurityKeyOptions } from '../types'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpSecurityKeyHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpSecurityKeyState\n  extends SignUpSecurityKeyHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signUpEmailSecurityKeyPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: SignUpSecurityKeyOptions\n): Promise<SignUpSecurityKeyHandlerResult> =>\n  new Promise<SignUpSecurityKeyHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_SECURITY_KEY', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import jwt_decode from 'jwt-decode'\nimport { interpret } from 'xstate'\nimport {\n  EMAIL_NEEDS_VERIFICATION,\n  INVALID_REFRESH_TOKEN,\n  INVALID_SIGN_IN_METHOD,\n  NO_REFRESH_TOKEN,\n  TOKEN_REFRESHER_RUNNING_ERROR\n} from './errors'\nimport { AuthClient } from './internal-client'\nimport {\n  AuthInterpreter,\n  createChangeEmailMachine,\n  createChangePasswordMachine,\n  createResetPasswordMachine,\n  createSendVerificationEmailMachine\n} from './machines'\nimport {\n  addSecurityKeyPromise,\n  changeEmailPromise,\n  changePasswordPromise,\n  resetPasswordPromise,\n  sendVerificationEmailPromise,\n  signInAnonymousPromise,\n  signInEmailPasswordlessPromise,\n  signInEmailPasswordPromise,\n  signInEmailSecurityKeyPromise,\n  signInMfaTotpPromise,\n  signInSmsPasswordlessOtpPromise,\n  signInSmsPasswordlessPromise,\n  signOutPromise,\n  signUpEmailPasswordPromise,\n  signUpEmailSecurityKeyPromise\n} from './promises'\nimport {\n  AuthChangedFunction,\n  AuthErrorPayload,\n  ChangeEmailParams,\n  ChangeEmailResponse,\n  ChangePasswordParams,\n  ChangePasswordResponse,\n  DeanonymizeParams,\n  DeanonymizeResponse,\n  JWTClaims,\n  JWTHasuraClaims,\n  NhostAuthConstructorParams,\n  NhostSessionResponse,\n  OnTokenChangedFunction,\n  ResetPasswordParams,\n  ResetPasswordResponse,\n  SecurityKey,\n  SendVerificationEmailParams,\n  SendVerificationEmailResponse,\n  SignInParams,\n  SignInResponse,\n  SignOutResponse,\n  SignUpParams,\n  SignUpResponse\n} from './types'\nimport {\n  encodeQueryParameters,\n  getAuthenticationResult,\n  getSession,\n  isBrowser,\n  rewriteRedirectTo\n} from './utils'\n\n/**\n * @alias Auth\n */\nexport class HasuraAuthClient {\n  private _client: AuthClient\n  readonly url: string\n  constructor({\n    url,\n    autoRefreshToken = true,\n    autoSignIn = true,\n    clientStorage,\n    clientStorageType,\n    refreshIntervalTime,\n    start = true\n  }: NhostAuthConstructorParams) {\n    this.url = url\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: (typeof window !== 'undefined' && window.location?.origin) || '',\n      autoRefreshToken,\n      autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      refreshIntervalTime\n    })\n  }\n\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ### Sign up with an email and password\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign up with a security key\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(params: SignUpParams): Promise<SignUpResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { email, options } = params\n    if ('securityKey' in params) {\n      return getAuthenticationResult(\n        await signUpEmailSecurityKeyPromise(interpreter, email, options)\n      )\n    }\n    return getAuthenticationResult(\n      await signUpEmailPasswordPromise(interpreter, email, params.password, options)\n    )\n  }\n\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @example\n   * ### Sign in anonymously\n   * ```ts\n   * // Sign in anonymously\n   * nhost.auth.signIn()\n   *\n   * // Later in the application, the user can complete their registration\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in with a security key\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(\n    params?: SignInParams\n  ): Promise<SignInResponse & { providerUrl?: string; provider?: string }> {\n    const interpreter = await this.waitUntilReady()\n    // * Anonymous sign-in\n    if (!params) {\n      const anonymousResult = await signInAnonymousPromise(interpreter)\n      return { ...getAuthenticationResult(anonymousResult), mfa: null }\n    }\n\n    // * Sign in with a social provider (OAuth)\n    if ('provider' in params) {\n      const { provider, options } = params\n      const providerUrl = encodeQueryParameters(\n        `${this._client.backendUrl}/signin/provider/${provider}`,\n        rewriteRedirectTo(this._client.clientUrl, options as any)\n      )\n      if (isBrowser()) {\n        window.location.href = providerUrl\n      }\n      return { providerUrl, provider, session: null, mfa: null, error: null }\n    }\n\n    // * Email + password\n    if ('email' in params && 'password' in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password)\n      if (res.needsEmailVerification) {\n        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION }\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        }\n      }\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    if ('email' in params && 'securityKey' in params) {\n      if (params.securityKey !== true) {\n        throw Error('securityKey must be true')\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless Email (magic link)\n    if ('email' in params) {\n      const { email, options } = params\n      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options)\n      return {\n        session: null,\n        mfa: null,\n        error\n      }\n    }\n\n    // * Passwordless SMS: [step 2/2] sign in using SMS OTP\n    if ('phoneNumber' in params && 'otp' in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless SMS: [step 1/2] sign in using SMS\n    if ('phoneNumber' in params) {\n      const { error } = await signInSmsPasswordlessPromise(\n        interpreter,\n        params.phoneNumber,\n        params.options\n      )\n      return { error, mfa: null, session: null }\n    }\n\n    // * Email + password MFA TOTP\n    if ('otp' in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    return { error: INVALID_SIGN_IN_METHOD, mfa: null, session: null }\n  }\n\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(params?: { all?: boolean }): Promise<SignOutResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { error } = await signOutPromise(interpreter, params?.all)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({ email, options }: ResetPasswordParams): Promise<ResetPasswordResponse> {\n    const service = interpret(createResetPasswordMachine(this._client)).start()\n    const { error } = await resetPasswordPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword,\n    ticket\n  }: ChangePasswordParams): Promise<ChangePasswordResponse> {\n    const service = interpret(createChangePasswordMachine(this._client)).start()\n    const { error } = await changePasswordPromise(service, newPassword, ticket)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email,\n    options\n  }: SendVerificationEmailParams): Promise<SendVerificationEmailResponse> {\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start()\n    const { error } = await sendVerificationEmailPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({ newEmail, options }: ChangeEmailParams): Promise<ChangeEmailResponse> {\n    const service = interpret(createChangeEmailMachine(this._client)).start()\n    const { error } = await changeEmailPromise(service, newEmail, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(params: DeanonymizeParams): Promise<DeanonymizeResponse> {\n    const interpreter = await this.waitUntilReady()\n    if (params.signInMethod === 'passwordless') {\n      if (params.connection === 'email') {\n        const { error } = await signInEmailPasswordlessPromise(\n          interpreter,\n          params.email,\n          params.options\n        )\n        return { error }\n      }\n      if (params.connection === 'sms') {\n        const { error } = await signInSmsPasswordlessPromise(\n          interpreter,\n          params.phoneNumber,\n          params.options\n        )\n        return { error }\n      }\n    }\n    if (params.signInMethod === 'email-password') {\n      const { error } = await signUpEmailPasswordPromise(\n        interpreter,\n        params.email,\n        params.password,\n        params.options\n      )\n      return { error }\n    }\n    throw Error(`Unknown deanonymization method`)\n  }\n\n  /**\n   * Use `nhost.auth.addSecurityKey to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(\n    nickname?: string\n  ): Promise<{ error: AuthErrorPayload | null; key?: SecurityKey }> {\n    const { error, key } = await addSecurityKeyPromise(this._client, nickname)\n    return { error, key }\n  }\n\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(fn: OnTokenChangedFunction): Function {\n    return this._client.subscribe(() => {\n      const subscription = this._client.interpreter?.onTransition(({ event, context }) => {\n        if (event.type === 'TOKEN_CHANGED') {\n          fn(getSession(context))\n        }\n      })\n      return () => subscription?.stop()\n    })\n  }\n\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(fn: AuthChangedFunction): Function {\n    return this._client.subscribe(() => {\n      const subscription = this._client.interpreter?.onTransition(({ event, context }) => {\n        if (event.type === 'SIGNED_IN' || event.type === 'SIGNED_OUT') {\n          fn(event.type, getSession(context))\n        }\n      })\n      return () => subscription?.stop()\n    })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this._client.interpreter?.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * The promise won't resolve until the authentication status is known.\n   * Attention: when using auto-signin and a refresh token is present in the client storage, the promise won't resolve if the server can't be reached (e.g. offline) or if it returns an internal error.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync(): Promise<boolean> {\n    const interpreter = await this.waitUntilReady()\n    return interpreter.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * The `connectionAttempts` returns the number of times the client has tried to connect to the server with no success (offline, or the server retruned an internal error).\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus(): {\n    isAuthenticated: boolean\n    isLoading: boolean\n    connectionAttempts: number\n  } {\n    const connectionAttempts =\n      this.client.interpreter?.getSnapshot().context.importTokenAttempts || 0\n    if (!this.isReady()) {\n      return {\n        isAuthenticated: false,\n        isLoading: true,\n        connectionAttempts\n      }\n    }\n    return { isAuthenticated: this.isAuthenticated(), isLoading: false, connectionAttempts }\n  }\n\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken(): string | undefined {\n    return this._client.interpreter?.getSnapshot().context.accessToken.value ?? undefined\n  }\n\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  public getDecodedAccessToken(): JWTClaims | null {\n    const jwt = this.getAccessToken()\n    if (!jwt) return null\n    return jwt_decode<JWTClaims>(jwt)\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  public getHasuraClaims(): JWTHasuraClaims | null {\n    return this.getDecodedAccessToken()?.['https://hasura.io/jwt/claims'] || null\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHsauraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  public getHasuraClaim(name: string): string | string[] | null {\n    return (\n      this.getHasuraClaims()?.[name.startsWith('x-hasura-') ? name : `x-hasura-${name}`] || null\n    )\n  }\n\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshToken();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshToken(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(refreshToken?: string): Promise<NhostSessionResponse> {\n    try {\n      const interpreter = await this.waitUntilReady()\n      return new Promise((resolve) => {\n        const token = refreshToken || interpreter.getSnapshot().context.refreshToken.value\n        if (!token) {\n          return resolve({ session: null, error: NO_REFRESH_TOKEN })\n        }\n        const { changed } = interpreter.send('TRY_TOKEN', { token })\n        if (!changed) {\n          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR })\n        }\n        interpreter.onTransition((state) => {\n          if (state.matches({ token: { idle: 'error' } })) {\n            resolve({\n              session: null,\n              // * TODO get the error from xstate once it is implemented\n              error: INVALID_REFRESH_TOKEN\n            })\n          } else if (state.event.type === 'TOKEN_CHANGED') {\n            resolve({ session: getSession(state.context), error: null })\n          }\n        })\n      })\n    } catch (error: any) {\n      // TODO return error in the correct format\n      return { session: null, error: error.message }\n    }\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    return getSession(this._client.interpreter?.getSnapshot()?.context)\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    return this._client.interpreter?.getSnapshot()?.context?.user || null\n  }\n\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  private waitUntilReady(): Promise<AuthInterpreter> {\n    const TIMEOUT_IN_SECONS = 15\n    const interpreter = this._client.interpreter\n    if (!interpreter) {\n      throw Error('Auth interpreter not set')\n    }\n    if (!interpreter.getSnapshot().hasTag('loading')) {\n      return Promise.resolve(interpreter)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: ReturnType<typeof setTimeout> = setTimeout(\n        () => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`),\n        TIMEOUT_IN_SECONS * 1_000\n      )\n      interpreter.onTransition((state) => {\n        if (!state.hasTag('loading')) {\n          clearTimeout(timer)\n          return resolve(interpreter)\n        }\n      })\n    })\n  }\n\n  private isReady() {\n    return !this._client.interpreter?.getSnapshot()?.hasTag('loading')\n  }\n\n  get client() {\n    return this._client\n  }\n}\n"],"names":["NHOST_REFRESH_TOKEN_KEY","NHOST_JWT_EXPIRES_AT_KEY","MIN_PASSWORD_LENGTH","TOKEN_REFRESH_MARGIN","REFRESH_TOKEN_MAX_ATTEMPTS","NETWORK_ERROR_CODE","OTHER_ERROR_CODE","VALIDATION_ERROR_CODE","STATE_ERROR_CODE","CodifiedError","original","INVALID_EMAIL_ERROR","INVALID_MFA_TYPE_ERROR","INVALID_MFA_CODE_ERROR","INVALID_PASSWORD_ERROR","INVALID_PHONE_NUMBER_ERROR","INVALID_MFA_TICKET_ERROR","NO_MFA_TICKET_ERROR","NO_REFRESH_TOKEN","TOKEN_REFRESHER_RUNNING_ERROR","USER_ALREADY_SIGNED_IN","USER_UNAUTHENTICATED","USER_NOT_ANONYMOUS","EMAIL_NEEDS_VERIFICATION","INVALID_REFRESH_TOKEN","INVALID_SIGN_IN_METHOD","INITIAL_MACHINE_CONTEXT","utf8StringToBuffer","value","bufferToBase64URLString","buffer","bytes","str","charCode","base64URLStringToBuffer","base64URLString","base64","padLength","padded","binary","i","browserSupportsWebAuthn","toPublicKeyCredentialDescriptor","descriptor","id","isValidDomain","hostname","WebAuthnError","message","name","identifyRegistrationError","error","options","_a","_b","publicKey","param","effectiveDomain","WebAuthnAbortService","webauthnAbortService","startRegistration","creationOptionsJSON","credential","err","rawId","response","type","credentialJSON","bufferToUTF8String","browserSupportsWebAuthnAutofill","globalPublicKeyCredential","identifyAuthenticationError","startAuthentication","requestOptionsJSON","useBrowserAutofill","allowCredentials","userHandle","isBrowser","inMemoryLocalStorage","defaultClientStorageGetter","key","defaultClientStorageSetter","localStorageGetter","clientStorageType","clientStorage","Cookies","localStorageSetter","getSession","context","getAuthenticationResult","accessToken","isError","user","fetchWrapper","url","method","token","body","headers","result","fetch","postFetch","getFetch","encodeQueryParameters","baseUrl","parameters","encodedParameters","stringValue","rewriteRedirectTo","clientUrl","redirectTo","otherOptions","baseClientUrl","clientParams","additionalParams","combinedParams","pathName","getParameterByName","regex","results","removeParameterFromWindow","location","search","hash","isValidEmail","email","isValidPassword","password","isValidPhoneNumber","phoneNumber","isValidTicket","ticket","createAuthMachine","backendUrl","refreshIntervalTime","autoRefreshToken","autoSignIn","storageGetter","storageSetter","postRequest","data","createMachine","send","assign","importTokenAttempts","_","accessTokenExpiresIn","nextRefresh","refreshToken","e","ctx","errors","expiresAt","otp","event","nickname","webAuthnOptions","urlToken","exception","storageToken","createChangeEmailMachine","interpreter","createChangePasswordMachine","createEnableMfaMachine","imageUrl","totpSecret","code","activeMfaType","createResetPasswordMachine","createSendVerificationEmailMachine","AuthClient","start","devTools","defaultOptions","existingToken","initialSession","machineWithInitialContext","interpret","fn","subscription","AuthCookieClient","AuthClientSSR","addSecurityKeyPromise","changeEmailPromise","resolve","s","changePasswordPromise","state","generateQrCodePromise","service","activateMfaPromise","resetPasswordPromise","sendVerificationEmailPromise","signInAnonymousPromise","changed","signInEmailPasswordPromise","signInEmailPasswordlessPromise","signInEmailSecurityKeyPromise","signInMfaTotpPromise","signInSmsPasswordlessPromise","signInSmsPasswordlessOtpPromise","signOutPromise","all","signUpEmailPasswordPromise","signUpEmailSecurityKeyPromise","HasuraAuthClient","params","anonymousResult","provider","providerUrl","res","newPassword","newEmail","connectionAttempts","jwt","jwt_decode","_c","reject","timer"],"mappings":"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"}