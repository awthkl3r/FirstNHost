{"version":3,"file":"index.esm.js","sources":["../src/utils/upload.ts","../src/hasura-storage-api.ts","../src/utils/appendImageTransformationParameters/appendImageTransformationParameters.ts","../src/hasura-storage-client.ts","../src/machines/file-upload.ts","../src/machines/multiple-files-upload.ts","../src/promises/file-upload.ts","../src/promises/multiple-files-upload.ts"],"sourcesContent":["import FormData from 'form-data'\nimport fetch from 'isomorphic-unfetch'\nimport { StorageErrorPayload, StorageUploadResponse } from './types'\n\n/** Convert any string into ISO-8859-1 */\nexport const toIso88591 = (fileName: string) => {\n  try {\n    btoa(fileName)\n    return fileName\n  } catch {\n    return encodeURIComponent(fileName)\n  }\n}\n\nexport const fetchUpload = async (\n  backendUrl: string,\n  data: FormData,\n  {\n    accessToken,\n    name,\n    fileId,\n    bucketId,\n    adminSecret,\n    onUploadProgress\n  }: {\n    accessToken?: string\n    name?: string\n    fileId?: string\n    bucketId?: string\n    adminSecret?: string\n    onUploadProgress?: (event: { total: number; loaded: number }) => void\n  } = {}\n): Promise<StorageUploadResponse> => {\n  const headers: HeadersInit = {}\n  if (fileId) {\n    headers['x-nhost-file-id'] = fileId\n  }\n  if (bucketId) {\n    headers['x-nhost-bucket-id'] = bucketId\n  }\n  if (name) {\n    headers['x-nhost-file-name'] = toIso88591(name)\n  }\n  if (adminSecret) {\n    headers['x-hasura-admin-secret'] = adminSecret\n  }\n  if (accessToken) {\n    headers['Authorization'] = `Bearer ${accessToken}`\n  }\n\n  const url = `${backendUrl}/files`\n  if (typeof XMLHttpRequest === 'undefined') {\n    // * Non-browser environment: XMLHttpRequest is not available\n    try {\n      const response = await fetch(url, {\n        method: 'POST',\n        headers,\n        body: data as any // * https://github.com/form-data/form-data/issues/513\n      })\n\n      if (!response.ok) {\n        const error: StorageErrorPayload = {\n          status: response.status,\n          message: await response.text(),\n          // * errors from hasura-storage are not codified\n          error: response.statusText\n        }\n        return { error, fileMetadata: null }\n      }\n      const fileMetadata = await response.json()\n      return { fileMetadata, error: null }\n    } catch (e) {\n      const error: StorageErrorPayload = {\n        status: 0,\n        message: (e as Error).message,\n        error: (e as Error).message\n      }\n      return { error, fileMetadata: null }\n    }\n  }\n  // * Browser environment: XMLHttpRequest is available\n  return new Promise((resolve) => {\n    let xhr = new XMLHttpRequest()\n    xhr.responseType = 'json'\n\n    xhr.onload = () => {\n      if (xhr.status < 200 && xhr.status >= 300) {\n        return resolve({\n          fileMetadata: null,\n          error: { error: xhr.statusText, message: xhr.statusText, status: xhr.status }\n        })\n      }\n      return resolve({ fileMetadata: xhr.response, error: null })\n    }\n\n    xhr.onerror = () => {\n      // only triggers if the request couldn't be made at all e.g. network error\n      return resolve({\n        fileMetadata: null,\n        error: { error: xhr.statusText, message: xhr.statusText, status: xhr.status }\n      })\n    }\n\n    if (onUploadProgress) {\n      xhr.upload.addEventListener('progress', onUploadProgress, false)\n    }\n\n    xhr.open('POST', url, true)\n\n    Object.entries(headers).forEach(([key, value]) => {\n      xhr.setRequestHeader(key, value)\n    })\n\n    xhr.send(data as any) // * https://github.com/form-data/form-data/issues/513\n  })\n}\n","import fetch from 'isomorphic-unfetch'\nimport {\n  ApiDeleteParams,\n  ApiDeleteResponse,\n  ApiGetPresignedUrlParams,\n  ApiGetPresignedUrlResponse,\n  ApiUploadParams,\n  StorageUploadResponse\n} from './utils/types'\nimport { fetchUpload } from './utils/upload'\n\n/**\n * @internal\n * This is an internal class.\n */\nexport class HasuraStorageApi {\n  private url: string\n  private accessToken?: string\n  private adminSecret?: string\n\n  constructor({ url }: { url: string }) {\n    this.url = url\n  }\n\n  async upload(params: ApiUploadParams): Promise<StorageUploadResponse> {\n    const { formData } = params\n\n    return fetchUpload(this.url, formData, {\n      accessToken: this.accessToken,\n      adminSecret: this.adminSecret,\n      bucketId: params.bucketId,\n      fileId: params.id,\n      name: params.name\n    })\n  }\n\n  async getPresignedUrl(params: ApiGetPresignedUrlParams): Promise<ApiGetPresignedUrlResponse> {\n    try {\n      const { fileId } = params\n      const response = await fetch(`${this.url}/files/${fileId}/presignedurl`, {\n        method: 'GET',\n        headers: this.generateAuthHeaders()\n      })\n      if (!response.ok) {\n        throw new Error(await response.text())\n      }\n      const presignedUrl = await response.json()\n      return { presignedUrl, error: null }\n    } catch (error) {\n      return { presignedUrl: null, error: error as Error }\n    }\n  }\n\n  async delete(params: ApiDeleteParams): Promise<ApiDeleteResponse> {\n    try {\n      const { fileId } = params\n      const response = await fetch(`${this.url}/files/${fileId}`, {\n        method: 'DELETE',\n        headers: this.generateAuthHeaders()\n      })\n      if (!response.ok) {\n        throw new Error(await response.text())\n      }\n      return { error: null }\n    } catch (error) {\n      return { error: error as Error }\n    }\n  }\n\n  /**\n   * Set the access token to use for authentication.\n   *\n   * @param accessToken Access token\n   * @returns Hasura Storage API instance\n   */\n  setAccessToken(accessToken?: string): HasuraStorageApi {\n    this.accessToken = accessToken\n\n    return this\n  }\n\n  /**\n   * Set the admin secret to use for authentication.\n   *\n   * @param adminSecret Hasura admin secret\n   * @returns Hasura Storage API instance\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageApi {\n    this.adminSecret = adminSecret\n\n    return this\n  }\n\n  private generateAuthHeaders(): HeadersInit | undefined {\n    if (!this.adminSecret && !this.accessToken) {\n      return undefined\n    }\n\n    if (this.adminSecret) {\n      return {\n        'x-hasura-admin-secret': this.adminSecret\n      }\n    }\n\n    return {\n      Authorization: `Bearer ${this.accessToken}`\n    }\n  }\n}\n","import { StorageImageTransformationParams } from '../types'\n\n/**\n * Appends image transformation parameters to the URL. If the URL already\n * contains query parameters, the transformation parameters are appended to\n * the existing query parameters.\n *\n * @internal\n * @param url - The URL to append the transformation parameters to.\n * @param params - The image transformation parameters.\n * @returns The URL with the transformation parameters appended.\n */\nexport default function appendImageTransformationParameters(\n  url: string,\n  params?: StorageImageTransformationParams\n): string {\n  if (!params || Object.keys(params).length === 0) {\n    return url\n  }\n\n  const urlObject = new URL(url)\n\n  // create an object with the transformation parameters by using the first\n  // character of the parameter name as the key\n  const imageTransformationParams = Object.entries(params).reduce(\n    (accumulator, [key, value]) => ({ ...accumulator, [key.charAt(0)]: value }),\n    {} as Record<string, any>\n  )\n\n  // set the query parameters in the URL object\n  Object.entries(imageTransformationParams).forEach(([key, value]) => {\n    if (!value) {\n      return\n    }\n\n    urlObject.searchParams.set(key, value)\n  })\n\n  return urlObject.toString()\n}\n","import FormData from 'form-data'\nimport { HasuraStorageApi } from './hasura-storage-api'\nimport {\n  appendImageTransformationParameters,\n  StorageDeleteParams,\n  StorageDeleteResponse,\n  StorageGetPresignedUrlParams,\n  StorageGetPresignedUrlResponse,\n  StorageGetUrlParams,\n  StorageUploadFileParams,\n  StorageUploadFormDataParams,\n  StorageUploadParams,\n  StorageUploadResponse\n} from './utils'\n\nexport interface NhostStorageConstructorParams {\n  /**\n   * Storage endpoint.\n   */\n  url: string\n  /**\n   * Admin secret. When set, it is sent as an `x-hasura-admin-secret` header for all requests.\n   */\n  adminSecret?: string\n}\n/**\n * @alias Storage\n */\nexport class HasuraStorageClient {\n  readonly url: string\n  private api: HasuraStorageApi\n\n  constructor({ url, adminSecret }: NhostStorageConstructorParams) {\n    this.url = url\n    this.api = new HasuraStorageApi({ url })\n    this.setAdminSecret(adminSecret)\n  }\n\n  /**\n   * Use `nhost.storage.upload` to upload a file. \n   * \n   * It's possible to use [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) or [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) to upload a file. The `File` instance is only available in the browser while `FormData` with [`form-data`](https://www.npmjs.com/package/form-data) works both in the browser and in NodeJS (server).\n   * \n   * If no `bucketId` is specified the bucket `default` is used.\n   *\n   * @example\n   * \n   * Upload a file from a browser using `File`.\n   * \n   * ```ts\n   * await nhost.storage.upload({ file })\n   * ```\n   * \n   * Upload a file from a browser using `File` to a specific Bucket.\n   * \n    @example\n   * ```ts\n   * await nhost.storage.upload({ file, bucketId: '<Bucket-ID>' })\n   * ```\n   * \n   * Upload a file from a server using `FormData` with [`form-data`](https://www.npmjs.com/package/form-data).\n   *\n   * @example\n   * ```ts\n   * const fd = new FormData() \n   * fd.append('file', fs.createReadStream('./tests/assets/sample.pdf'))\n   * \n   * await storage.upload({\n   *   formData: fd\n   * })\n   * ```\n   * \n   * @docs https://docs.nhost.io/reference/javascript/storage/upload\n   */\n\n  async upload(params: StorageUploadFileParams): Promise<StorageUploadResponse>\n  async upload(params: StorageUploadFormDataParams): Promise<StorageUploadResponse>\n  async upload(params: StorageUploadParams): Promise<StorageUploadResponse> {\n    let formData: FormData\n\n    if ('file' in params) {\n      formData = new FormData()\n      formData.append('file', params.file)\n    } else {\n      formData = params.formData\n    }\n\n    return this.api.upload({\n      ...params,\n      formData\n    })\n  }\n\n  /**\n   * Use `nhost.storage.getPublicUrl` to get the public URL of a file. The public URL can be used for un-authenticated users to access files. To access public files the `public` role must have permissions to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const publicUrl = nhost.storage.getPublicUrl({ fileId: '<File-ID>' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-public-url\n   */\n  getPublicUrl(params: StorageGetUrlParams): string {\n    const { fileId, ...imageTransformationParams } = params\n    return appendImageTransformationParameters(\n      `${this.url}/files/${fileId}`,\n      imageTransformationParams\n    )\n  }\n\n  /**\n   * Use `nhost.storage.getPresignedUrl` to get a presigned URL of a file. To get a presigned URL the user must have permission to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const { presignedUrl, error} = await nhost.storage.getPresignedUrl({ fileId: '<File-ID>' })\n   *\n   * if (error) {\n   *   throw error;\n   * }\n   *\n   * console.log('url: ', presignedUrl.url)\n   * console.log('expiration: ', presignedUrl.expiration)\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-presigned-url\n   */\n  async getPresignedUrl(\n    params: StorageGetPresignedUrlParams\n  ): Promise<StorageGetPresignedUrlResponse> {\n    const { fileId, ...imageTransformationParams } = params\n    const { presignedUrl, error } = await this.api.getPresignedUrl(params)\n    if (error) {\n      return { presignedUrl: null, error }\n    }\n\n    if (!presignedUrl) {\n      return { presignedUrl: null, error: new Error('Invalid file id') }\n    }\n\n    const urlWithTransformationParams = appendImageTransformationParameters(\n      presignedUrl.url,\n      imageTransformationParams\n    )\n\n    return {\n      presignedUrl: {\n        ...presignedUrl,\n        url: urlWithTransformationParams\n      },\n      error: null\n    }\n  }\n\n  /**\n   * Use `nhost.storage.delete` to delete a file. To delete a file the user must have permissions to delete the file in the `storage.files` table. Deleting the file using `nhost.storage.delete()` will delete both the file and its metadata.\n   *\n   * @example\n   * ```ts\n   * const { error } = await nhost.storage.delete({ fileId: 'uuid' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/delete\n   */\n  async delete(params: StorageDeleteParams): Promise<StorageDeleteResponse> {\n    const { error } = await this.api.delete(params)\n    if (error) {\n      return { error }\n    }\n\n    return { error: null }\n  }\n\n  /**\n   * Use `nhost.storage.setAccessToken` to a set an access token to be used in subsequent storage requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAccessToken('some-access-token')\n   * ```\n   *\n   * @param accessToken Access token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-access-token\n   */\n  setAccessToken(accessToken?: string): HasuraStorageClient {\n    this.api.setAccessToken(accessToken)\n\n    return this\n  }\n\n  /**\n   * Use `nhost.storage.adminSecret` to set the admin secret to be used for subsequent storage requests. This is useful if you want to run storage in \"admin mode\".\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAdminSecret('some-admin-secret')\n   * ```\n   *\n   * @param adminSecret Hasura admin secret\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-admin-secret\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageClient {\n    this.api.setAdminSecret(adminSecret)\n\n    return this\n  }\n}\n","import FormData from 'form-data'\nimport { assign, createMachine } from 'xstate'\nimport { FileUploadConfig, StorageErrorPayload } from '../utils'\nimport { fetchUpload } from '../utils/upload'\n\nexport type FileUploadContext = {\n  progress: number | null\n  loaded: number\n  error: StorageErrorPayload | null\n  id?: string\n  bucketId?: string\n  file?: File\n}\n\nexport type FileUploadEventPayload = {}\nexport type FileUploadEvents =\n  | { type: 'ADD'; file: File; id?: string; bucketId?: string; name?: string }\n  | ({\n      type: 'UPLOAD'\n      file?: File\n      id?: string\n      name?: string\n      bucketId?: string\n    } & FileUploadConfig)\n  | { type: 'UPLOAD_PROGRESS'; progress: number; loaded: number; additions: number }\n  | { type: 'UPLOAD_DONE'; id: string; bucketId: string }\n  | { type: 'UPLOAD_ERROR'; error: StorageErrorPayload }\n  | { type: 'CANCEL' }\n  | { type: 'DESTROY' }\n\nexport const INITIAL_FILE_CONTEXT: FileUploadContext = {\n  progress: null,\n  loaded: 0,\n  error: null,\n  bucketId: undefined,\n  file: undefined,\n  id: undefined\n}\n\nexport type FileUploadMachine = ReturnType<typeof createFileUploadMachine>\nexport const createFileUploadMachine = () =>\n  createMachine(\n    {\n      predictableActionArguments: true,\n      schema: {\n        context: {} as FileUploadContext,\n        events: {} as FileUploadEvents\n      },\n      tsTypes: {} as import('./file-upload.typegen').Typegen0,\n      context: { ...INITIAL_FILE_CONTEXT },\n      initial: 'idle',\n      on: {\n        DESTROY: { actions: 'sendDestroy', target: 'stopped' }\n      },\n      states: {\n        idle: {\n          on: {\n            ADD: { actions: 'addFile' },\n            UPLOAD: { cond: 'hasFile', target: 'uploading' }\n          }\n        },\n        uploading: {\n          entry: 'resetProgress',\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress', 'sendProgress'] },\n            UPLOAD_DONE: 'uploaded',\n            UPLOAD_ERROR: 'error',\n            CANCEL: 'idle'\n          },\n          invoke: { src: 'uploadFile' }\n        },\n        uploaded: {\n          entry: ['setFileMetadata', 'sendDone'],\n          on: {\n            ADD: { actions: 'addFile', target: 'idle' },\n            UPLOAD: { actions: 'resetContext', target: 'uploading' }\n          }\n        },\n        error: {\n          entry: ['setError', 'sendError'],\n          on: {\n            ADD: { actions: 'addFile', target: 'idle' },\n            UPLOAD: { actions: 'resetContext', target: 'uploading' }\n          }\n        },\n        stopped: { type: 'final' }\n      }\n    },\n    {\n      guards: {\n        hasFile: (context, event) => !!context.file || !!event.file\n      },\n\n      actions: {\n        incrementProgress: assign({\n          loaded: (_, { loaded }) => loaded,\n          progress: (_, { progress }) => progress\n        }),\n        setFileMetadata: assign({\n          id: (_, { id }) => id,\n          bucketId: (_, { bucketId }) => bucketId,\n          progress: (_) => 100\n        }),\n        setError: assign({ error: (_, { error }) => error }),\n        sendProgress: () => {},\n        sendError: () => {},\n        sendDestroy: () => {},\n        sendDone: () => {},\n        resetProgress: assign({ progress: (_) => null, loaded: (_) => 0 }),\n        resetContext: assign((_) => INITIAL_FILE_CONTEXT),\n        addFile: assign({\n          file: (_, { file }) => file,\n          bucketId: (_, { bucketId }) => bucketId,\n          id: (_, { id }) => id\n        })\n      },\n      services: {\n        uploadFile: (context, event) => (callback) => {\n          const file = (event.file || context.file)!\n          const data = new FormData()\n          data.append('file', file)\n\n          let currentLoaded = 0\n\n          fetchUpload(event.url, data, {\n            fileId: event.id || context.id,\n            bucketId: event.bucketId || context.bucketId,\n            accessToken: event.accessToken,\n            adminSecret: event.adminSecret,\n            name: event.name || file.name,\n            onUploadProgress: (event) => {\n              const loaded = event.total ? Math.round((event.loaded * file.size!) / event.total) : 0\n              const additions = loaded - currentLoaded\n              currentLoaded = loaded\n              callback({\n                type: 'UPLOAD_PROGRESS',\n                progress: event.total ? Math.round((loaded * 100) / event.total) : 0,\n                loaded,\n                additions\n              })\n            }\n          }).then(({ fileMetadata, error }) => {\n            if (error) {\n              callback({ type: 'UPLOAD_ERROR', error })\n            }\n            if (fileMetadata) {\n              const { id, bucketId } = fileMetadata\n              callback({ type: 'UPLOAD_DONE', id, bucketId })\n            }\n          })\n\n          return () => {}\n        }\n      }\n    }\n  )\n","import { actions, ActorRefFrom, assign, createMachine, send, spawn } from 'xstate'\n\nimport { FileUploadConfig } from '../utils'\n\nimport { createFileUploadMachine, FileUploadMachine, INITIAL_FILE_CONTEXT } from './file-upload'\n\nconst { pure, sendParent } = actions\n\nexport type FileItemRef = ActorRefFrom<FileUploadMachine>\n\nexport type AnyFileList = File | File[] | FileList\n\nexport type MultipleFilesUploadContext = {\n  progress: number | null\n  files: FileItemRef[]\n  loaded: number\n  total: number\n}\n\nexport type MultipleFilesUploadEvents =\n  | { type: 'ADD'; files: AnyFileList; bucketId?: string }\n  | ({\n      type: 'UPLOAD'\n      files?: AnyFileList\n      bucketId?: string\n    } & FileUploadConfig)\n  | { type: 'UPLOAD_PROGRESS'; additions: number }\n  | { type: 'UPLOAD_DONE' }\n  | { type: 'UPLOAD_ERROR' }\n  | { type: 'CANCEL' }\n  | { type: 'REMOVE' }\n  | { type: 'CLEAR' }\n\nexport type MultipleFilesUploadMachine = ReturnType<typeof createMultipleFilesUploadMachine>\n\nexport const createMultipleFilesUploadMachine = () => {\n  return createMachine(\n    {\n      id: 'files-list',\n      schema: {\n        context: {} as MultipleFilesUploadContext,\n        events: {} as MultipleFilesUploadEvents\n      },\n      tsTypes: {} as import('./multiple-files-upload.typegen').Typegen0,\n      predictableActionArguments: true,\n      context: {\n        progress: null,\n        files: [],\n        loaded: 0,\n        total: 0\n      },\n      initial: 'idle',\n      on: {\n        UPLOAD: { cond: 'hasFileToDownload', actions: 'addItem', target: 'uploading' },\n        ADD: { actions: 'addItem' },\n        REMOVE: { actions: 'removeItem' }\n      },\n      states: {\n        idle: {\n          entry: ['resetProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        uploading: {\n          entry: ['upload', 'startProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress'] },\n            UPLOAD_DONE: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            UPLOAD_ERROR: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            CANCEL: { actions: 'cancel', target: 'idle' }\n          }\n        },\n        uploaded: {\n          entry: 'setUploaded',\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        error: {\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        }\n      }\n    },\n    {\n      guards: {\n        hasFileToDownload: (context, event) =>\n          context.files.some((ref) => ref.getSnapshot()!.matches('idle')) || !!event.files,\n        isAllUploaded: (context) =>\n          context.files.every((item) => item.getSnapshot()?.matches('uploaded')),\n        isAllUploadedOrError: (context) =>\n          context.files.every((item) => {\n            const snap = item.getSnapshot()\n            return snap?.matches('error') || snap?.matches('uploaded')\n          })\n      },\n\n      actions: {\n        incrementProgress: assign((context, event) => {\n          const loaded: number = context.loaded + event.additions\n          const progress = Math.round((loaded * 100) / context.total)\n          return { ...context, loaded, progress }\n        }),\n        setUploaded: assign({\n          progress: (_) => 100,\n          loaded: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetTotal: assign({\n          total: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => !snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetLoaded: assign({ loaded: (_) => 0 }),\n        startProgress: assign({ progress: (_) => 0 }),\n        resetProgress: assign({ progress: (_) => null }),\n        addItem: assign((context, { files, bucketId }) => {\n          const additions = files\n            ? Array.isArray(files)\n              ? files // File[]\n              : 'item' in files // FileList\n              ? Array.from(files)\n              : [files] // File\n            : [] // No file\n          const total = context.total + additions.reduce((agg, curr) => agg + curr.size, 0)\n          const progress = Math.round((context.loaded * 100) / total)\n          return {\n            files: [\n              ...context.files,\n              ...additions.map((file) =>\n                spawn(\n                  createFileUploadMachine()\n                    .withConfig({\n                      actions: {\n                        sendProgress: sendParent((_, { additions }) => ({\n                          type: 'UPLOAD_PROGRESS',\n                          additions\n                        })),\n                        sendDone: sendParent('UPLOAD_DONE'),\n                        sendError: sendParent('UPLOAD_ERROR'),\n                        sendDestroy: sendParent('REMOVE')\n                      }\n                    })\n                    .withContext({ ...INITIAL_FILE_CONTEXT, file, bucketId }),\n                  { sync: true }\n                )\n              )\n            ],\n            total,\n            loaded: context.loaded,\n            progress\n          }\n        }),\n        removeItem: assign({\n          files: (context) =>\n            context.files.filter((ref) => {\n              const stopped = ref.getSnapshot()?.matches('stopped')\n              if (stopped) {\n                ref.stop?.()\n              }\n              return !stopped\n            })\n        }),\n        clearList: pure((context) =>\n          context.files.map((ref) => send({ type: 'DESTROY' }, { to: ref.id }))\n        ),\n        upload: pure((context, event) => context.files.map((ref) => send(event, { to: ref.id }))),\n        cancel: pure((context) =>\n          context.files.map((ref) => send({ type: 'CANCEL' }, { to: ref.id }))\n        )\n      }\n    }\n  )\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { FileItemRef, FileUploadMachine } from '../machines'\nimport { FileUploadConfig, StorageActionErrorState, StorageUploadFileParams } from '../utils'\n\nexport interface UploadProgressState {\n  /**\n   * Returns `true` when the file is being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface UploadFileHandlerResult extends StorageActionErrorState {\n  /**\n   * Returns `true` when the file has been successfully uploaded.\n   */\n  isUploaded: boolean\n  /**\n   * Returns the id of the file.\n   */\n  id?: string\n  /**\n   * Returns the bucket id.\n   */\n  bucketId?: string\n  /**\n   * Returns the name of the file.\n   */\n  name?: string\n}\n\nexport interface FileUploadState extends UploadFileHandlerResult, UploadProgressState {}\n\nexport const uploadFilePromise = async (\n  params: FileUploadConfig & Partial<StorageUploadFileParams>,\n  interpreter: FileItemRef | InterpreterFrom<FileUploadMachine>\n): Promise<UploadFileHandlerResult> =>\n  new Promise<UploadFileHandlerResult>((resolve) => {\n    interpreter.send({\n      type: 'UPLOAD',\n      ...params\n    })\n    interpreter.subscribe((s) => {\n      if (s.matches('error')) {\n        resolve({\n          error: s.context.error,\n          isError: true,\n          isUploaded: false\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({\n          error: null,\n          isError: false,\n          isUploaded: true,\n          id: s.context.id,\n          bucketId: s.context.id,\n          name: s.context.file?.name\n        })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { AnyFileList, FileItemRef, MultipleFilesUploadMachine } from '../machines'\nimport { FileUploadConfig } from '../utils'\n\nexport interface MultipleUploadProgressState {\n  /**\n   * Returns `true` when the files are being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the overall progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface MultipleFilesHandlerResult {\n  /**\n   * The list of file uploads. The properties can be accessed through `item.getSnapshot()` of with the `useFileUploadItem` hook.\n   */\n  files: FileItemRef[]\n  /**\n   * Returns `true` when all upload request are processed, but at least one of them has failed.\n   */\n  isError: boolean\n  /**\n   * Returns the list of file uploads that have failed\n   */\n  errors: FileItemRef[]\n}\n\nexport interface MultipleFilesUploadState\n  extends MultipleFilesHandlerResult,\n    MultipleUploadProgressState {\n  /**\n   * Returns `true` when all the files have been successfully uploaded.\n   */\n  isUploaded: boolean\n}\n\nexport type UploadMultipleFilesActionParams = {\n  files?: AnyFileList\n  bucketId?: string\n}\n\nexport const uploadMultipleFilesPromise = async (\n  params: FileUploadConfig & UploadMultipleFilesActionParams,\n  service: InterpreterFrom<MultipleFilesUploadMachine>\n): Promise<MultipleFilesHandlerResult> =>\n  new Promise((resolve) => {\n    service.send({\n      type: 'UPLOAD',\n      ...params,\n      files: params.files\n    })\n    service.onTransition((s) => {\n      if (s.matches('error')) {\n        resolve({\n          errors: s.context.files.filter((ref) => ref.getSnapshot()?.context.error),\n          isError: true,\n          files: []\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({ errors: [], isError: false, files: s.context.files })\n      }\n    })\n  })\n"],"names":["toIso88591","fileName","fetchUpload","backendUrl","data","accessToken","name","fileId","bucketId","adminSecret","onUploadProgress","headers","url","response","fetch","e","resolve","xhr","key","value","HasuraStorageApi","params","formData","error","appendImageTransformationParameters","urlObject","imageTransformationParams","accumulator","HasuraStorageClient","FormData","presignedUrl","urlWithTransformationParams","INITIAL_FILE_CONTEXT","createFileUploadMachine","createMachine","context","event","assign","_","loaded","progress","id","file","callback","currentLoaded","additions","fileMetadata","pure","sendParent","actions","createMultipleFilesUploadMachine","ref","item","_a","snap","files","agg","curr","total","spawn","stopped","_b","send","uploadFilePromise","interpreter","uploadMultipleFilesPromise","service"],"mappings":"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"}