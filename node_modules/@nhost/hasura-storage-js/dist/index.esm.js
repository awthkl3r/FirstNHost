import m from "isomorphic-unfetch";
import D from "form-data";
import { createMachine as O, assign as d, spawn as L, send as h, actions as T } from "xstate";
const S = (t) => {
  try {
    return btoa(t), t;
  } catch {
    return encodeURIComponent(t);
  }
}, U = async (t, e, {
  accessToken: r,
  name: s,
  fileId: o,
  bucketId: n,
  adminSecret: a,
  onUploadProgress: l
} = {}) => {
  const c = {};
  o && (c["x-nhost-file-id"] = o), n && (c["x-nhost-bucket-id"] = n), s && (c["x-nhost-file-name"] = S(s)), a && (c["x-hasura-admin-secret"] = a), r && (c.Authorization = `Bearer ${r}`);
  const p = `${t}/files`;
  if (typeof XMLHttpRequest == "undefined")
    try {
      const u = await m(p, {
        method: "POST",
        headers: c,
        body: e
      });
      return u.ok ? { fileMetadata: await u.json(), error: null } : { error: {
        status: u.status,
        message: await u.text(),
        error: u.statusText
      }, fileMetadata: null };
    } catch (u) {
      return { error: {
        status: 0,
        message: u.message,
        error: u.message
      }, fileMetadata: null };
    }
  return new Promise((u) => {
    let i = new XMLHttpRequest();
    i.responseType = "json", i.onload = () => i.status < 200 && i.status >= 300 ? u({
      fileMetadata: null,
      error: { error: i.statusText, message: i.statusText, status: i.status }
    }) : u({ fileMetadata: i.response, error: null }), i.onerror = () => u({
      fileMetadata: null,
      error: { error: i.statusText, message: i.statusText, status: i.status }
    }), l && i.upload.addEventListener("progress", l, !1), i.open("POST", p, !0), Object.entries(c).forEach(([P, y]) => {
      i.setRequestHeader(P, y);
    }), i.send(e);
  });
};
class R {
  constructor({ url: e }) {
    this.url = e;
  }
  async upload(e) {
    const { formData: r } = e;
    return U(this.url, r, {
      accessToken: this.accessToken,
      adminSecret: this.adminSecret,
      bucketId: e.bucketId,
      fileId: e.id,
      name: e.name
    });
  }
  async getPresignedUrl(e) {
    try {
      const { fileId: r } = e, s = await m(`${this.url}/files/${r}/presignedurl`, {
        method: "GET",
        headers: this.generateAuthHeaders()
      });
      if (!s.ok)
        throw new Error(await s.text());
      return { presignedUrl: await s.json(), error: null };
    } catch (r) {
      return { presignedUrl: null, error: r };
    }
  }
  async delete(e) {
    try {
      const { fileId: r } = e, s = await m(`${this.url}/files/${r}`, {
        method: "DELETE",
        headers: this.generateAuthHeaders()
      });
      if (!s.ok)
        throw new Error(await s.text());
      return { error: null };
    } catch (r) {
      return { error: r };
    }
  }
  setAccessToken(e) {
    return this.accessToken = e, this;
  }
  setAdminSecret(e) {
    return this.adminSecret = e, this;
  }
  generateAuthHeaders() {
    if (!(!this.adminSecret && !this.accessToken))
      return this.adminSecret ? {
        "x-hasura-admin-secret": this.adminSecret
      } : {
        Authorization: `Bearer ${this.accessToken}`
      };
  }
}
function E(t, e) {
  if (!e || Object.keys(e).length === 0)
    return t;
  const r = new URL(t), s = Object.entries(e).reduce(
    (o, [n, a]) => ({ ...o, [n.charAt(0)]: a }),
    {}
  );
  return Object.entries(s).forEach(([o, n]) => {
    n && r.searchParams.set(o, n);
  }), r.toString();
}
class k {
  constructor({ url: e, adminSecret: r }) {
    this.url = e, this.api = new R({ url: e }), this.setAdminSecret(r);
  }
  async upload(e) {
    let r;
    return "file" in e ? (r = new D(), r.append("file", e.file)) : r = e.formData, this.api.upload({
      ...e,
      formData: r
    });
  }
  getPublicUrl(e) {
    const { fileId: r, ...s } = e;
    return E(
      `${this.url}/files/${r}`,
      s
    );
  }
  async getPresignedUrl(e) {
    const { fileId: r, ...s } = e, { presignedUrl: o, error: n } = await this.api.getPresignedUrl(e);
    if (n)
      return { presignedUrl: null, error: n };
    if (!o)
      return { presignedUrl: null, error: new Error("Invalid file id") };
    const a = E(
      o.url,
      s
    );
    return {
      presignedUrl: {
        ...o,
        url: a
      },
      error: null
    };
  }
  async delete(e) {
    const { error: r } = await this.api.delete(e);
    return r ? { error: r } : { error: null };
  }
  setAccessToken(e) {
    return this.api.setAccessToken(e), this;
  }
  setAdminSecret(e) {
    return this.api.setAdminSecret(e), this;
  }
}
const A = {
  progress: null,
  loaded: 0,
  error: null,
  bucketId: void 0,
  file: void 0,
  id: void 0
}, _ = () => O(
  {
    predictableActionArguments: !0,
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    context: { ...A },
    initial: "idle",
    on: {
      DESTROY: { actions: "sendDestroy", target: "stopped" }
    },
    states: {
      idle: {
        on: {
          ADD: { actions: "addFile" },
          UPLOAD: { cond: "hasFile", target: "uploading" }
        }
      },
      uploading: {
        entry: "resetProgress",
        on: {
          UPLOAD_PROGRESS: { actions: ["incrementProgress", "sendProgress"] },
          UPLOAD_DONE: "uploaded",
          UPLOAD_ERROR: "error",
          CANCEL: "idle"
        },
        invoke: { src: "uploadFile" }
      },
      uploaded: {
        entry: ["setFileMetadata", "sendDone"],
        on: {
          ADD: { actions: "addFile", target: "idle" },
          UPLOAD: { actions: "resetContext", target: "uploading" }
        }
      },
      error: {
        entry: ["setError", "sendError"],
        on: {
          ADD: { actions: "addFile", target: "idle" },
          UPLOAD: { actions: "resetContext", target: "uploading" }
        }
      },
      stopped: { type: "final" }
    }
  },
  {
    guards: {
      hasFile: (t, e) => !!t.file || !!e.file
    },
    actions: {
      incrementProgress: d({
        loaded: (t, { loaded: e }) => e,
        progress: (t, { progress: e }) => e
      }),
      setFileMetadata: d({
        id: (t, { id: e }) => e,
        bucketId: (t, { bucketId: e }) => e,
        progress: (t) => 100
      }),
      setError: d({ error: (t, { error: e }) => e }),
      sendProgress: () => {
      },
      sendError: () => {
      },
      sendDestroy: () => {
      },
      sendDone: () => {
      },
      resetProgress: d({ progress: (t) => null, loaded: (t) => 0 }),
      resetContext: d((t) => A),
      addFile: d({
        file: (t, { file: e }) => e,
        bucketId: (t, { bucketId: e }) => e,
        id: (t, { id: e }) => e
      })
    },
    services: {
      uploadFile: (t, e) => (r) => {
        const s = e.file || t.file, o = new D();
        o.append("file", s);
        let n = 0;
        return U(e.url, o, {
          fileId: e.id || t.id,
          bucketId: e.bucketId || t.bucketId,
          accessToken: e.accessToken,
          adminSecret: e.adminSecret,
          name: e.name || s.name,
          onUploadProgress: (a) => {
            const l = a.total ? Math.round(a.loaded * s.size / a.total) : 0, c = l - n;
            n = l, r({
              type: "UPLOAD_PROGRESS",
              progress: a.total ? Math.round(l * 100 / a.total) : 0,
              loaded: l,
              additions: c
            });
          }
        }).then(({ fileMetadata: a, error: l }) => {
          if (l && r({ type: "UPLOAD_ERROR", error: l }), a) {
            const { id: c, bucketId: p } = a;
            r({ type: "UPLOAD_DONE", id: c, bucketId: p });
          }
        }), () => {
        };
      }
    }
  }
), { pure: g, sendParent: f } = T, M = () => O(
  {
    id: "files-list",
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    predictableActionArguments: !0,
    context: {
      progress: null,
      files: [],
      loaded: 0,
      total: 0
    },
    initial: "idle",
    on: {
      UPLOAD: { cond: "hasFileToDownload", actions: "addItem", target: "uploading" },
      ADD: { actions: "addItem" },
      REMOVE: { actions: "removeItem" }
    },
    states: {
      idle: {
        entry: ["resetProgress", "resetLoaded", "resetTotal"],
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      },
      uploading: {
        entry: ["upload", "startProgress", "resetLoaded", "resetTotal"],
        on: {
          UPLOAD_PROGRESS: { actions: ["incrementProgress"] },
          UPLOAD_DONE: [
            { cond: "isAllUploaded", target: "uploaded" },
            { cond: "isAllUploadedOrError", target: "error" }
          ],
          UPLOAD_ERROR: [
            { cond: "isAllUploaded", target: "uploaded" },
            { cond: "isAllUploadedOrError", target: "error" }
          ],
          CANCEL: { actions: "cancel", target: "idle" }
        }
      },
      uploaded: {
        entry: "setUploaded",
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      },
      error: {
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      }
    }
  },
  {
    guards: {
      hasFileToDownload: (t, e) => t.files.some((r) => r.getSnapshot().matches("idle")) || !!e.files,
      isAllUploaded: (t) => t.files.every((e) => {
        var r;
        return (r = e.getSnapshot()) == null ? void 0 : r.matches("uploaded");
      }),
      isAllUploadedOrError: (t) => t.files.every((e) => {
        const r = e.getSnapshot();
        return (r == null ? void 0 : r.matches("error")) || (r == null ? void 0 : r.matches("uploaded"));
      })
    },
    actions: {
      incrementProgress: d((t, e) => {
        const r = t.loaded + e.additions, s = Math.round(r * 100 / t.total);
        return { ...t, loaded: r, progress: s };
      }),
      setUploaded: d({
        progress: (t) => 100,
        loaded: ({ files: t }) => t.map((e) => e.getSnapshot()).filter((e) => e.matches("uploaded")).reduce((e, r) => {
          var s;
          return e + ((s = r.context.file) == null ? void 0 : s.size);
        }, 0)
      }),
      resetTotal: d({
        total: ({ files: t }) => t.map((e) => e.getSnapshot()).filter((e) => !e.matches("uploaded")).reduce((e, r) => {
          var s;
          return e + ((s = r.context.file) == null ? void 0 : s.size);
        }, 0)
      }),
      resetLoaded: d({ loaded: (t) => 0 }),
      startProgress: d({ progress: (t) => 0 }),
      resetProgress: d({ progress: (t) => null }),
      addItem: d((t, { files: e, bucketId: r }) => {
        const s = e ? Array.isArray(e) ? e : "item" in e ? Array.from(e) : [e] : [], o = t.total + s.reduce((a, l) => a + l.size, 0), n = Math.round(t.loaded * 100 / o);
        return {
          files: [
            ...t.files,
            ...s.map(
              (a) => L(
                _().withConfig({
                  actions: {
                    sendProgress: f((l, { additions: c }) => ({
                      type: "UPLOAD_PROGRESS",
                      additions: c
                    })),
                    sendDone: f("UPLOAD_DONE"),
                    sendError: f("UPLOAD_ERROR"),
                    sendDestroy: f("REMOVE")
                  }
                }).withContext({ ...A, file: a, bucketId: r }),
                { sync: !0 }
              )
            )
          ],
          total: o,
          loaded: t.loaded,
          progress: n
        };
      }),
      removeItem: d({
        files: (t) => t.files.filter((e) => {
          var s, o;
          const r = (s = e.getSnapshot()) == null ? void 0 : s.matches("stopped");
          return r && ((o = e.stop) == null || o.call(e)), !r;
        })
      }),
      clearList: g(
        (t) => t.files.map((e) => h({ type: "DESTROY" }, { to: e.id }))
      ),
      upload: g((t, e) => t.files.map((r) => h(e, { to: r.id }))),
      cancel: g(
        (t) => t.files.map((e) => h({ type: "CANCEL" }, { to: e.id }))
      )
    }
  }
), b = async (t, e) => new Promise((r) => {
  e.send({
    type: "UPLOAD",
    ...t
  }), e.subscribe((s) => {
    var o;
    s.matches("error") ? r({
      error: s.context.error,
      isError: !0,
      isUploaded: !1
    }) : s.matches("uploaded") && r({
      error: null,
      isError: !1,
      isUploaded: !0,
      id: s.context.id,
      bucketId: s.context.id,
      name: (o = s.context.file) == null ? void 0 : o.name
    });
  });
}), F = async (t, e) => new Promise((r) => {
  e.send({
    type: "UPLOAD",
    ...t,
    files: t.files
  }), e.onTransition((s) => {
    s.matches("error") ? r({
      errors: s.context.files.filter((o) => {
        var n;
        return (n = o.getSnapshot()) == null ? void 0 : n.context.error;
      }),
      isError: !0,
      files: []
    }) : s.matches("uploaded") && r({ errors: [], isError: !1, files: s.context.files });
  });
});
export {
  R as HasuraStorageApi,
  k as HasuraStorageClient,
  A as INITIAL_FILE_CONTEXT,
  E as appendImageTransformationParameters,
  _ as createFileUploadMachine,
  M as createMultipleFilesUploadMachine,
  b as uploadFilePromise,
  F as uploadMultipleFilesPromise
};
//# sourceMappingURL=index.esm.js.map
